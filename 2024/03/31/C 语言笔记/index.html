<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>C 语言笔记 | 这不是Cola</title><meta name="keywords" content="C语言"><meta name="author" content="这不是Cola,hifz@vip.qq.com"><meta name="copyright" content="这不是Cola"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="C 语言笔记"><meta name="application-name" content="C 语言笔记"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta name="referrer" content="no-referrer" /><meta property="og:type" content="article"><meta property="og:title" content="C 语言笔记"><meta property="og:url" content="https://blog.xykcola.site/2024/03/31/C%20%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/index.html"><meta property="og:site_name" content="这不是Cola"><meta property="og:description" content="前言此笔记是本人根据谭浩强的教材《C程序设计（第五版）》及其结合自己在网上找的再自己写的。认真看完它并加上充分的练习应对期末、专升本应该是足够了，当然你也可以作为巩固复习资料使用，对初学者也是有一定的作用。当然，本人也是初学水平所做的复习笔记，如有不足之处还请谅解指正内容多，请结合大纲使用 第1章"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://cdn.xykcola.site/blogPics/post/202405/202405271431216.jpg"><meta property="article:author" content="这不是Cola"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.xykcola.site/blogPics/post/202405/202405271431216.jpg"><meta name="description" content="前言此笔记是本人根据谭浩强的教材《C程序设计（第五版）》及其结合自己在网上找的再自己写的。认真看完它并加上充分的练习应对期末、专升本应该是足够了，当然你也可以作为巩固复习资料使用，对初学者也是有一定的作用。当然，本人也是初学水平所做的复习笔记，如有不足之处还请谅解指正内容多，请结合大纲使用 第1章"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://blog.xykcola.site/2024/03/31/C%20%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?f53ebfbe441850085fab6345754f7049";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-NV871JX04X"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-NV871JX04X');
</script><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: undefined,
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: {"enable":true,"ck":"3IY12ZjgPLAI8wEh","LingQueMonitorID":"3IY2O4NwKeT4wN50"},
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: 'https://twikoo.xykcola.site/',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: {"apiurl":null},
  navMusic: true,
  mainTone: {"mode":"api","api":"https://img2color-go.vercel.app/api?img=","cover_change":true},
  authorStatus: {"skills":["🤖️ 数码科技爱好者","🔍 分享与热心帮助","🏠 智能家居小能手","🔨 设计开发一条龙","🤝 专修交互与设计","🏃 脚踏实地行动派","🧱 团队小组发动机","💢 壮汉人狠话不多"]},
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: 这不是Cola","link":"链接: ","source":"来源: 这不是Cola","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: '这不是Cola',
  title: 'C 语言笔记',
  postAI: '',
  pageFillDescription: '前言, 第1章 程序设计和C语言, C语言的发展及其特点, 结构化程序设计方法的思想, 编辑、编译、运行一个C程序的步骤, 第2章 算法——程序的灵魂, 算法的概念, 算法的特点, 怎样表示一个算法, 能够利用传统流程图和N-S流程图描述算法, 第3章 最简单的C程序设计—顺序程序设计, 常量和变量, 关键字和标识符, 数据类型, 运算符与表达式, 数据的输入输出, 第4章 选择结构程序设计, 关系、逻辑运算符, 条件运算符, if 语句, Switch Break 语句, 第5章 循环结构程序设计, while 循环, do while 循环, for 循环, break、continue作用, 第6章 利用数组处理批量数据, 数组, 一维数组, 二维数组, 第7章 用函数实现模块化程序设计, 为什么要用函数, 定义函数, 调用函数, 函数递归, 数组作为函数参数, 局部变量和全局变量, 变量的存储方式和生存期, 局部变量的存储类别, 全局变量存储类别, 外部函数与内部函数, 第8章 善于利用指针, 指针的含义, 指针变量, 指针引用数组, 指针引用字符串, 指向函数的指针, 动态内存分配, 第9章 用户自己建立数据类型, 结构体变量, 结构体指针, 指针处理链表, 共用体类型, 枚举类型, 第10章 对文件的输入输出, C文件基本知识, 打开与关闭文件, 文件字符读写, 文件字符串读写, 格式化方式读写文本文件, 二进制文件数据块读写, 随机读写数据文件前言此笔记是本人根据谭浩强的教材程序设计第五版及其结合自己在网上找的再自己写的认真看完它并加上充分的练习应对期末专升本应该是足够了当然你也可以作为巩固复习资料使用对初学者也是有一定的作用当然本人也是初学水平所做的复习笔记如有不足之处还请谅解指正内容多请结合大纲使用第章程序设计和语言语言的发展及其特点语言发展语言是由贝尔实验室的在世纪年代初开发的一种通用计算机编程语言语言的设计目标是提供一种高效可移植的编程语言用于系统级编程和应用程序开发其发展可以分为以下几个阶段诞生和发展初期年代语言最初是为了开发操作系统而设计的在这个阶段语言的设计和实现主要由和完成他们通过语言的简洁和灵活性成功地将系统移植到不同的计算机平台上标准化年代随着语言的流行和广泛应用人们开始意识到需要一个标准化的语言规范以确保不同的编译器能够产生相同的结果于是美国国家标准学会和国际标准化组织联合制定了语言的标准规范于年发布了标准语言的变体和扩展年代在语言的基础上出现了一些变体和扩展如等是由在年代初开发的它在语言的基础上增加了面向对象编程的特性是由在年代初开发的它在语言的基础上增加了面向对象编程和动态运行时特性标准更新年代至今语言的标准规范在年和年分别进行了更新分别发布了和标准这些更新主要是为了提供更多的特性和功能以适应计算机技术的发展和应用需求的变化语言特点语言简洁紧凑使用灵活方便灵活运算符丰富数据类型丰富具有结构化的控制语句语句语句语句等允许直接访问物理地址能进行位操作能实现编汇语言的大部分功能可以直接对硬件进行操作语言的程序的基本程序结构一个程序由一个或多个源程序文件组成预处理指令预处理指令是在编译之前对源代码进行处理的指令由以开头的特殊语句组成预处理指令不是真正的语句而是用来指导编译器在编译之前进行一些处理操作的用于引入头文件将头文件的内容插入到当前位置用于定义宏将标识符替换为指定的值或代码片段全局声明全局声明是指在函数外部声明的变量或函数其作用域在整个程序中都可见全局声明可以在任何函数中使用而不需要在每个函数中重新声明把放到了函数之前函数定义函数定义是指在程序中实现函数的具体功能函数定义包括函数的返回类型函数名参数列表和函数体返回类型函数名参数列表函数体执行具体的功能可能包含一条或多条语句其中返回类型指定函数的返回值类型函数名是函数的标识符参数列表是函数接受的输入参数函数体是函数的具体实现在上述函数定义中返回类型是函数名是参数列表是函数体中计算了和的和并将结果存储在变量中最后通过语句返回了的值函数定义可以在程序中的任何位置通常放在函数之前函数定义的目的是将函数的实现与函数的声明分离使代码更加模块化和可维护需要注意的是函数定义必须与函数声明一致即函数的返回类型函数名和参数列表必须与函数声明中的一致否则会导致编译错误函数是程序的主要组成部分函数是程序的主要组成部分它们是用来执行特定任务的代码块通过将代码分解为多个函数可以使程序更加模块化和可维护每个函数都有特定的功能可以独立地编写测试和调试程序的执行从函数开始可以在函数中调用其他函数来完成不同的任务函数可以接受输入参数并返回一个值用于传递数据和获取函数的结果通过使用函数可以提高程序的可读性可重用性和可扩展性一个函数包括两部分函数首部函数首部是指函数的声明或定义中的第一行用于指定函数的返回类型函数名和参数列表函数首部的一般形式如下返回类型函数名参数列表其中返回类型指定函数返回的数据类型可以是基本类型如等或者自定义的结构体类型函数名是函数的标识符用于在程序中调用该函数参数列表指定函数接受的参数类型和参数名多个参数之间用逗号分隔举例这个函数首部声明了一个名为的函数返回类型为接受两个类型的参数和这个函数首部声明了一个名为的函数返回类型为接受一个类型的数组和一个类型的参数这个函数首部声明了一个名为的函数返回类型为即无返回值不接受任何参数函数体函数体是函数定义或声明中的代码块用于实现函数的具体功能函数体的一般形式如下返回类型函数名参数列表函数体代码其中返回类型与函数首部中的返回类型相对应指定函数返回的数据类型函数名与函数首部中的函数名相对应用于在程序中调用该函数参数列表与函数首部中的参数列表相对应指定函数接受的参数类型和参数名举例这个函数体实现了一个名为的函数接受一个类型的参数计算的平方并返回结果在函数体中先定义一个局部变量将乘以的结果赋值给然后使用语句将作为函数的返回值返回程序总是从函数开始执行程序中要求计算机的操作是由函数中的语句完成的在每个数据声明和语句的最后必须要有一个分号下面是一个满足上述要求的完整语言代码示例最大值是你好世界在这个例子中程序由一个源文件组成首先使用预处理指令引入标准库头文件这样我们就可以使用和等标准库函数然后在全局声明部分我们声明了两个函数和它们的函数原型分别出现在函数之前用于告诉编译器这两个函数的返回类型函数名和参数列表接下来我们定义了主函数它是程序的入口点在函数中我们声明了两个整型变量和然后调用了函数来求出和的最大值并将结果存储在变量中最后我们使用函数打印出最大值和一个简单的问候语在函数和函数的定义中我们分别实现了这两个函数的功能函数接受两个整型参数并通过比较来确定最大值并使用语句返回该值函数不接受参数直接打印出一个问候语最后我们在函数最后返回了表示程序正常结束请注意每个语句和声明末尾都有一个分号这是语言中的语法规则这些分号用于表示语句的结束结构化程序设计方法的思想模块化将程序分解为多个模块或函数每个模块或函数负责处理特定的功能或任务模块化的设计使得程序结构清晰易于理解和维护自顶向下设计从整体到局部的设计思路先设计整体的程序结构和主要功能然后逐步细化为更小的模块或函数这种设计方法使得程序的层次结构清晰易于理解和开发顺序选择和循环结构使用顺序选择和循环结构来组织程序的逻辑流程顺序结构按照代码的顺序执行选择结构根据条件选择不同的执行路径循环结构重复执行一段代码数据抽象和封装将数据和对数据的操作封装在模块或函数中只暴露必要的接口给外部使用这种封装和抽象的方式提高了程序的可读性可维护性和可重用性模块间的通信模块之间通过参数传递和返回值来进行数据的交换和通信模块之间的通信应该尽量简洁明了避免过多的全局变量和副作用编辑编译运行一个程序的步骤上机输入和编辑源程序语言文件后缀对源程序进行编译预处理阶段是在编译之前进行的主要处理以开头的预处理指令如包含头文件宏定义等预处理器会根据这些指令对源代码进行处理生成一个经过宏展开条件编译等处理的新的源代码文件编译阶段将预处理后的源代码转换为汇编代码编译器会对源代码进行词法分析语法分析和语义分析生成对应的中间代码通常是汇编代码汇编阶段将汇编代码转换为机器代码汇编器会将汇编代码翻译成机器指令生成目标文件通常是以或为扩展名进行链接处理链接阶段将目标文件与其他的目标文件或库文件进行合并生成最终的可执行文件链接器会解析目标文件中的符号引用将其与其他目标文件或库文件中的符号定义进行匹配生成最终的可执行文件运行可执行文件得到运行结果第章算法程序的灵魂算法的概念一个程序包括两个方面算法数据结构程序对数据的描述在程序中要指定用到哪些数据以及这些数据的类型和数据的组成形式这就是数据结构对操作的描述要求计算机操作的步骤也就是算法算法的特点有穷性一个算法应该包括有限的操作步骤确定性算法中的每一个步骤都应该是确定的有零个或多个输入输入是指在执行算法时需要从外界取得必要的信息有一个或多个输出算法的目的是为了求解解就是输出有效性算法中的每个步骤都应当能有效地进行并得到确定的结果怎样表示一个算法用自然语言就是讲人话解释清楚用流程图算法表示传统流程图传统流程图是一种图形化的工具用于描述算法或程序的执行流程它由各种不同形状的框和箭头组成表示程序中的不同步骤和控制流程流程图流程图是一种简单的图表用来描述一个过程或流程中的各个步骤和决策它使用箭头表示流程的方向起点为终点为在流程图中不同的步骤和决策用不同的图形和符号表示通过这种图表人们可以清晰地了解和描述一个过程中的执行顺序和条件判断举例输入三角形三边长判断三遍构成的是等边等腰还是一般三角形用伪代码表示算法伪代码是一种类似于编程语言的描述性语言用于描述算法或程序的逻辑结构和执行流程它不是一种具体的编程语言而是一种方便程序员理解和描述算法的工具伪代码通常使用类似于编程语言的语法和关键字但不需要遵循具体语言的语法规则示例计算两个数的和输入两个数计算和第一个数第二个数显示和结束用计算机语言比如用语言表示能够利用传统流程图和流程图描述算法上面以及写过了不用我在解释了吧关键在多练多做题你就会了第章最简单的程序设计顺序程序设计常量和变量一常量在程序运行的过程中其值不能被改变的量称为常量整型常量实型常量十进制小数形式有数字和小数组成指数形式字符常量普通字符用单引号括起来的单个字符在语言中普通字符在计算机中的存储通常使用编码编码使用一个字节位来表示一个字符范围从到其中到是控制字符到是可打印字符而是删除字符例如字符的码是以二进制表示为在计算机中该字符会被存储为一个字节即位从高位到低位依次为表转义字符以开头的字符在语言中使用字符串时有时候需要插入一些特殊字符或者控制字符这时就可以使用转义字符来实现转义字符以反斜杠开头后面跟着一个或多个字符用来表示特定的含义例如代表换行符当我们在字符串中插入时编译器会将其解释为换行符输出时会在该位置换行同样地代表制表符代表回车符代表退格符代表换页符等等字符串常量双引号括起来的若干个字符符号常量用指令指定用一个符号名称代表一个常量末尾没有分号程序用到就代表是二变量在程序运行期间其值可以改变的量叫做变量变量在使用前需要先声明声明变量时需要指定变量的类型和名称在语言中变量的声明和使用有一些不同的语法下面是一个使用变量的语言例子声明一个整数类型的变量声明一个字符类型的变量声明一个浮点数类型的变量修改变量的值输出变量的值在上面的例子中我们首先包含了头文件该头文件中包含了输入输出函数的声明然后在函数中声明了三个变量和并给它们赋予了初始值接着我们修改了变量的值并使用函数输出了变量的值在语言中变量的类型需要在声明时指定并且变量名需要遵循一定的命名规则不同的变量类型可以存储不同类型的数据通过修改变量的值我们可以改变变量存储的数据需要注意的是在语言中变量的声明通常放在函数的开头而变量的使用可以放在任意位置三常变量在定义变量前加一个表示该变量是常量其值不能被修改常变量一旦被初始化其值将在整个程序执行过程中保持不变举例在上述例子中被声明为一个常变量其值为该值在程序执行期间不能被修改关键字和标识符一标识符用来表示变量函数类结构体等程序实体的名称叫做标识符标识符的命名规则如下可以使用大小写字母数字和下划线标识符开头必须是字符或者是下划线不能以数字开头标识符区分大小写例如和是不同的标识符标识符不能是语言的关键字如等二关键字关键字是在编程语言中具有特殊含义和用途的保留字它们被编程语言用于表示语法结构控制流程定义数据类型等特定的功能和用途关键字具有固定的语法和语义不能作为标识符来使用在语言中关键字用于表示条件判断循环函数返回值数据类型等例如关键字用于表示条件判断关键字用于表示循环关键字用于定义整型数据类型举例数据类型在语言中数据类型用于定义变量的类型以及变量可以存储的数据范围和操作一整型数据基本整型型占用个字节取值范围为到或到短整型型占用个字节取值范围为到或到长整型型占用个字节位系统或个字节位系统取值范围为到双长整型型占用个字节取值范围为到在定义基本整型外是可以像以下便捷操作的关键字可以省略实际上等价于以下代码二整型变量的符号属性语言中的整型变量可以具有符号属性有符号或无符号属性无符号这取决于变量的声明方式有符号整型变量可以表示正数负数和零而无符号整型变量只能表示非负数包括零有符号整型变量的取值范围是从负最大值到正最大值之间例如类型的取值范围是到有符号整型变量的计算方式使用补码表示即正数的二进制表示与无符号整型相同而负数使用补码表示无符号整型变量的取值范围是从到正最大值之间例如类型的取值范围是到无符号整型变量的计算方式直接使用二进制表示在语言中整型变量的符号属性可以通过声明时的类型修饰符来指定例如有符号整型变量无符号整型变量如果不明确指定符号属性默认情况下和被视为有符号和无符号整型变量类型占用字节数字节取值范围到类型占用字节数字节取值范围到类型占用字节数字节位系统或字节位系统取值范围到类型占用字节数字节取值范围到三字符型数据由于字符是按其代码整数形式储存的因此在语言中字符型数据作为整数类型的一种但它又有自己的特点需单独拿出来讲字符与字符代码字符与字符代码并不是任写一个字符程序都能识别例如代表圆周率的就是不能识别的只能使用系统的字符集中的字符目前大多数系统大多采用字符集字符变量字符变量就是用类型符定义字符变量是英文字符的缩写见名知意有符号字符型一般写作字节数通常为个字节位取值范围到无符号字符型字节数通常为个字节位取值范围到四浮点型数据用来表示具有小数点的实数单精度浮点型型通常占用个字节位其有效数字位数为约位该类型可以表示大约到之间的数值双精度浮点型型通常占用个字节位其有效数字位数为约位该类型可以表示大约到之间的数值长双精度型型占用的字节数较为可变通常是个字节或更多其有效数字位数也会相应增加这种类型通常提供比更高的精度需要注意的是数据类型的大小取值范围和有效数字位数可能会因编译器和平台的不同而有所变化运算符与表达式语言提供了很多运算符当前章节就讲讲算术运算符与赋值运算符一基本算术运算符加法运算符将两个操作数相加减法运算符从第一个操作数中减去第二个操作数乘法运算符将两个操作数相乘除法运算符将第一个操作数除以第二个操作数得到商因为是整型所以结果没有小数点取模运算符将第一个操作数除以第二个操作数得到余数正号运算符表达数据为正负号运算符表达数据位负二自增自减运算符自增运算符有两种形式前缀形式和后缀形式前缀形式的自增运算符会先将操作数的值增加然后返回增加后的值后缀形式的自增运算符会先返回操作数的值然后再将其增加自减运算符的使用方法与自增运算符类似只是将值减少前缀形式的自减运算符会先将操作数的值减少然后返回减少后的值后缀形式的自减运算符会先返回操作数的值然后再将其减少三算术表达式语言的算术表达式是由操作数运算符和括号组成的表达式用于表示数值之间的运算关系语言支持一系列算术运算符包括加法减法乘法除法和取模等算术表达式可以包含整数浮点数和字符类型的操作数这些操作数可以直接使用字面值也可以是变量或表达式的结果例如下面是一些语言的算术表达式的示例整数运算加法运算的值为减法运算的值为乘法运算的值为除法运算的值为整数除法取模运算的值为浮点数运算加法运算的值为乘法运算的值为除法运算的值为混合类型运算加法运算的值为乘法运算的值为除法运算的值为例如表达式可以通过加上括号来明确指定运算的顺序同时也遵循先乘除后加减的优先级原则此外语言还支持一些其他的算术运算符和特殊的运算规则如自增自减赋值运算符等四不同数据类型之间的混合运算在语言中不同类型之间的混合运算指的是在表达式中使用不同类型的操作数进行运算当表达式中存在不同类型的操作数时语言会根据一组规则来确定运算的结果类型整数和浮点数的混合运算如果一个操作数是浮点数那么另一个操作数将被自动转换为浮点数结果将是浮点数如果一个操作数是整数而另一个操作数是浮点数那么整数将被自动转换为浮点数结果将是浮点数整数被自动转换为浮点数结果为浮点数整数被自动转换为浮点数结果为浮点数字符和整数的混合运算字符可以被视为整数类型因此可以与整数进行运算字符与整数之间的运算结果将是整数字符被视为整数类型结果为整数是一个字符类型变量其值为对应的码值为是一个整数类型变量其值为因此最终结果是不同整数类型的混合运算如果两个操作数的类型不同那么语言会将它们转换为相同的类型然后进行运算转换的规则是将较小的整数类型转换为较大的整数类型类型的被转换为类型结果为类型需要注意的是混合运算可能会导致数据丢失或精度损失因此在进行混合运算时应该确保转换是安全和合理的以避免出现错误总之在语言中不同类型之间的混合运算是允许的并且根据一组规则来确定运算的结果类型理解这些规则对于正确编写和理解表达式非常重要五强制类型转换运算符语言中的强制类型转换运算符是一种用于显式地指定数据类型转换的运算符它的语法形式是在要转换的值或表达式前面加上括号并在括号内指定要转换的目标类型例如其中表示目标类型表示要转换的值或表达式强制类型转换运算符可以用于以下几种情况将一个表达式的结果强制转换为特定的类型将整数强制转换为浮点数类型将一个变量的类型强制转换为另一种类型将整数强制转换为字符类型在混合运算中显式地指定操作数的类型将表达式的结果强制转换为整数类型注意强制类型转换只是转换当前的临时值但该表达式结束后数据仍为原类型如第二个例子在过后还是整型需要注意的是强制类型转换可能会导致数据的截断或溢出因此在进行强制类型转换时应该确保转换是安全的并且不会导致数据丢失或溢出此外强制类型转换运算符的优先级较高因此在表达式中使用时需要注意运算顺序可以使用括号来明确指定运算顺序六赋值语句赋值运算符将一个数据赋值给一个变量把常量赋值给变量复合赋值运算符语言中的复合赋值运算符是一种简化表达式的方式它将运算符和赋值操作结合在一起下面是语言中的所有复合赋值运算符及其解释加法赋值运算符将右操作数的值加到左操作数上并将结果赋给左操作数例如等价于减法赋值运算符将右操作数的值从左操作数中减去并将结果赋给左操作数例如等价于乘法赋值运算符将右操作数的值乘以左操作数并将结果赋给左操作数例如等价于除法赋值运算符将左操作数的值除以右操作数并将结果赋给左操作数例如等价于取模赋值运算符将左操作数的值除以右操作数得到的余数并将结果赋给左操作数例如等价于数据的输入输出一用函数输出数据函数格式输出函数用来向终端输出若干个任意类型的数据函数的一般格式格式控制输出列表举例格式控制是用英文双引号括起来的一个字符串称为格式控制字符串简称格式字符串包含以下两个信息格式声明由和格式字符组成如将输出的数据转换为指定的格式后输出总是有开始的普通字符即需要输出时原样输出的字符如双引号中的逗号空格换行符输出列表是程序需要输出的一些数据可以是常量变量或者表达式如上例中的和格式字符在输出时不同的数据类型需要指定不同的格式声明格式声明中最重要的内容是格式字符格式字符用于输出有符号十进制整数输出输出格式符用于输出无符号十进制整数输出格式符用于输出浮点数基本型用输出指定数据宽度和小数位数用代表输出的数据占几位代表输出几位小数输出中的代表输出的数据占位其中包括小数点和小数位数代表输出位小数因此输出结果为小数点前面有个空格总共占了位输出的数据向左对齐用代表输出的数据占几位代表输出几位小数代表向左对齐格式符用于输出字符输出格式符用于输出字符串输出格式符用于输出指针地址输出根据具体内存地址而定用于输出十六进制整数小写字母用于输出十六进制整数大写字母用于输出八进制整数用于输出科学计数法表示的浮点数小写字母用于输出科学计数法表示的浮点数大写字母根据数值的大小自动选择使用或格式输出浮点数小写字母根据数值的大小自动选择使用或格式输出浮点数大写字母用于输出百分号注意在格式声明中在和上述格式字符键可以插入以下附加字符又称修饰符长整型整数长整型整数是一种数据类型用于存储比普通整数更大的整数值可以加在格式符前面如使用打印类型的整数输出使用打印类型的整数输出字符代表数据最小宽度实数表示输出位小数对字符串表示截取的字符个数都代表一个正整数使用打印整数最小宽度为输出使用打印浮点数最小宽度为小数位数为输出使用打印字符输出定义了一个整数一个浮点数和一个字符使用不同的格式符来打印这些数据同时指定了最小宽度和小数位数使用来打印整数其中表示最小宽度使用来打印浮点数其中表示最小宽度表示小数位数使用来打印字符输出的数字或字符在域内向左靠当我们使用标志时输出的数字或字符将在域内向左靠齐下面是一个使用标志的语言代码示例使用打印整数最小宽度为左对齐输出使用打印浮点数最小宽度为小数位数为左对齐输出使用打印字符左对齐输出在上面的代码中我们定义了一个整数一个浮点数和一个字符使用标志与其他格式符一起使用来使输出的数字或字符在域内向左靠齐使用来打印整数其中表示最小宽度使用来打印浮点数其中表示最小宽度表示小数位数使用来打印字符这些格式符与标志一起使用可以使输出的数字或字符在域内向左靠齐二函数输入数据一般形式格式控制地址列表格式控制含义同函数的格式控制地址表列由若干个地址组成的表列可以是变量的地址或字符串的首地址为取地址符字如其意在语言中函数用于从用户输入中读取数据它的工作方式是通过引用传递来修改变量的值为了让函数能够修改变量的值我们需要向其提供变量的地址这就是在中使用的原因运算符用于获取变量的地址当我们在中使用运算符时它表示我们要将变量的地址传递给函数以便它可以直接修改变量的值示例使用获取的地址并将用户输入的值存储在中用户输入的值在上面的示例中函数使用格式说明符来读取用户输入的整数为了让函数能够修改的值我们使用运算符获取的地址并将其传递给函数需要注意的是运算符只能用于具有内存地址的变量它不能用于常量表达式或函数调用的结果格式声明与函数中的格式声明相似以开始以一个格式字符结束中间也可以插入附加的字符为取地址符字如其意格式符输入有符号的十进制整数格式符输入无符号的十进制格式符输入无符号的八进制格式符输入无符号的十六进制整数大小写作用相同格式符输入单个字符格式符输入字符串将字符串送到一个字符数组中在输入时以非空白字符开始以第一个空白字符结束字符串以标志作为其最后一个字符格式符输入实数可以用小数形式或指数形式输入格式符与作用相同与可以互相替换大小写作用相同函数中用到的格式附加字符字符输入长整型数据如以及型数据类型字符输入短整型数据如字符本输入项在输入后不赋给相应的变量字符代表输入数据所占宽度代表一个正整数三字符输入输出函数函数输出一个字符只要是字符都可以字符类型也属于整数类型对照表与都输出字符一般形式为一个字符函数输入一个字符一般形式从键盘输入一个字符传给字符变量第章选择结构程序设计关系逻辑运算符关系运算符在语言中关系运算符用于比较两个值之间的关系结果为真非零或假零逻辑运算符用于组合多个关系表达式结果为真或假语言中常用的关系运算符相等不等大于小于大于等于小于等于逻辑运算符逻辑运算符用于组合多个关系表达式常用的逻辑运算符有逻辑与逻辑或逻辑非表达式是由操作数和运算符组成的操作数可以是变量常量或表达式的结果运算符用于操作操作数通过组合运算符和操作数可以构建复杂的表达式来进行计算和判断例如下面的表达式计算两个数的平均值计算和的和然后除以得到平均值在这个表达式中计算了和的和然后除以得到平均值并将结果存储在变量中条件运算符在语言中条件运算符也称为三元运算符是一种简洁的条件表达式用于根据条件的真假选择不同的值条件运算符的语法如下其中是一个条件表达式其结果可以是真非零值或假零值如果条件表达式为真则整个表达式的值为如果条件表达式为假则整个表达式的值为条件运算符的示例在上面的示例中如果大于则被赋值为的值否则被赋值为的值语句语句是一种条件语句用于在满足特定条件时执行一段代码它的基本操作包括以下几个步骤检查条件首先语句会检查指定的条件是否为真非零条件可以是一个表达式也可以是一个变量的值如果条件为真即满足条件那么将执行语句后面的代码块如果条件为假即为那么将跳过语句的代码块继续执行后面的代码执行代码块如果条件为真那么将执行语句后面的代码块代码块是由一对花括号包围的一组语句组成可以是单个语句或多个语句的集合这些语句可以是任何合法的语言语句例如变量赋值函数调用条件语句循环语句等跳过代码块如果条件为假那么将跳过语句后面的代码块继续执行后面的代码这意味着语句的代码块只会在条件为真时执行否则将被忽略使用语句的示例用于判断一个数是否为正数这个数是正的在这个示例中语句检查的条件是否为真因为的值为满足条件所以将执行语句后面的代码块输出这个数是正的如果的值为负数或零那么条件为假将跳过语句的代码块不会输出任何内容语句的三种形式语句语句用于在条件为真时执行一段代码语法如下当为真时执行的代码例如下面的代码根据变量的值判断是否为正数并输出相应的信息这个数是正的如果的值大于则条件为真将会执行语句输出语句语句用于在条件为真时执行一个代码块否则执行另一个代码块语法如下当为真时执行的代码当为假时执行的代码例如下面的代码根据变量的值判断是否为正数并输出相应的信息这个数是正的这个数不是正的如果的值大于则条件为真将会执行第一个语句输出这个数是正的否则将会执行第二个语句输出这个数不是正的语句语句用于根据多个条件选择不同的代码块执行语法如下当为真时执行的代码当为真时执行的代码当所有条件都为假时执行的代码例如下面的代码根据变量的值判断学生的等级并输出相应的信息根据的值将会执行相应的语句输出对应的等级在这个例子中的值为满足第二个条件因此将会执行第二个语句输出语句语句是一种多分支选择结构用于根据不同的条件执行不同的代码块它的基本语法如下表达式值如果表达式匹配值则执行这里的代码值如果表达式匹配值则执行这里的代码值如果表达式匹配值则执行这里的代码如果表达式不匹配任何值则执行这里的代码语句的执行过程如下表达式求值首先计算表达式的值表达式可以是一个变量或一个常量值匹配值接下来将计算得到的表达式的值与每个语句后面的值进行比较以确定是否匹配执行代码块如果匹配成功即表达式的值与某个语句后面的值相等那么将执行该语句后面的代码块代码块是由一对花括号包围的一组语句组成跳出语句在执行完匹配的代码块后程序会继续执行后面的代码为了避免执行其他语句后面的代码块可以在每个语句的末尾使用语句来跳出语句如果表达式的值与任何语句后面的值都不匹配那么将执行语句后面的代码块如果有语句是可选的用于处理表达式不匹配的情况使用语句的示例根据用户输入的数字输出相应的季节请输入一个月份冬季春季夏季秋季输入的月份无效第章循环结构程序设计循环循环是一种常用的循环结构它的作用是在满足指定条件的情况下重复执行一段代码块以下是循环的基本语法条件要执行的代码在循环开始之前首先会对条件进行评估如果条件为真非零值循环体中的代码将会被执行执行完循环体中的代码后再次对条件进行评估如果条件仍然为真循环将会继续执行直到条件为假零值此时循环结束程序继续执行循环之后的代码以下是一个使用循环的示例程序用于打印从到的数字在这个程序中作为循环的条件只要的值小于等于循环体中的代码都会被执行循环体中首先会打印当前的的值然后通过将的值增加以准备下一次循环程序会重复执行这个过程直到的值大于循环就会结束以上程序的输出结果为循环语言中的语句是一种循环结构用于重复执行一段代码块直到满足指定的条件为止它的基本语法如下循环体代码条件循环的执行过程是先执行一次循环体代码然后再检查条件是否满足如果条件为真则继续执行循环体代码如果条件为假则退出循环下面是一个使用循环的示例程序计算到的累加和到的累加和是在这个程序中使用循环计算了到的累加和首先将初始化为然后在循环体内将添加到中并递增的值当的值小于等于时继续执行循环体代码当的值达到时不满足条件退出循环最后输出累加和的结果循环语句是一种常用的循环结构用于重复执行一个代码块可以指定起始条件循环条件和循环迭代它的基本语法如下初始化语句循环条件迭代语句循环体代码循环的执行过程是先执行初始化语句然后检查循环条件是否满足如果条件为真则执行循环体代码并执行迭代语句如果条件为假则退出循环下面是一个使用循环的示例程序计算到的累加和到的累加和是在这个程序中使用循环计算了到的累加和循环的初始化语句将初始化为循环的条件是小于等于循环的迭代语句是对进行递增操作在每次循环中将添加到中当循环条件不满足时即大于时退出循环最后输出累加和的结果作用语句可用于语句的跳出和循环中断的跳出语句语句用于中断当前所在的循环结构即在满足某个条件时提前跳出循环结束循环的执行当语句执行时程序将跳出当前的循环并执行循环后面的代码下面是一个使用语句的示例程序其中使用了一个无限循环循环并在满足某个条件时使用语句跳出循环请输入一个整数输入结束循环如果输入的整数是则跳出循环你输入的整数是循环结束在这个程序中使用了一个无限循环循环并在循环内部输入一个整数如果输入的整数是则使用语句跳出循环否则输出输入的整数当输入的整数为时循环将被提前结束跳出循环并执行后续的代码语句语句用于终止当前循环迭代中的剩余语句并进入下一次循环迭代也就是说当程序执行到语句时会跳过当前循环迭代剩余的代码然后继续下一次迭代通过使用一个循环找出一个整数数组中的偶数并输出这些偶数如果是奇数则跳过当前循环迭代继续下一次迭代在这个示例中使用一个循环迭代整数数组当遇到奇数时使用语句跳过当前迭代继续下一次迭代只有当遇到偶数时才会执行输出语句因此程序输出结果为第章利用数组处理批量数据数组数组的定义语言中的数组可用于存储一系列相同类型的元素数组可以在内存中连续存储多个元素并通过索引或者叫下标来访问和操作这些元素数组的定义形式数据类型数组名数组长度数据类型指定了数组中元素的类型数组名是数组的标识符数组长度指定了数组可以存储的元素个数定义一个包含个整数的数组数组的初始化数组的初始化可以在定义时进行也可以在后续的代码中进行静态初始化在定义时就定义了所有数据动态初始化先定义数组再后续定义数据数组的长度是固定的一旦定义后就不能改变如果需要存储更多的元素可以重新定义一个更大长度的数组并将原数组中的元素复制到新数组中数组的访问在语言中可以使用索引或者叫下标来访问数组中的元素数组的索引或者叫下标从开始递增表示数组中元素的位置访问数组元素的方式为数组名索引例如对于一个包含个整数的数组可以使用索引来表示数组中的第个第个第个第个和第个元素访问数组中的第个元素的值为访问数组中的第个元素的值为修改数组中的第个元素将其值改为注意数组的索引必须在合法的范围内即从到数组长度减如果使用超出范围的索引来访问数组元素将会导致未定义的行为可能会访问到无效的内存地址一维数组一维数组是由一组具有相同数据类型的元素组成的这些元素按照一维的方式排列在连续的内存空间中一维数组可以看作是一个线性的数据结构可以通过索引来访问和操作数组中的元素刚刚对于数组的解释全都是属于一维数组的范畴二维数组二维数组是一种特殊的数组它包含一组具有相同数据类型的元素这些元素按照二维的方式排列在连续的内存空间中二维数组可以看作是一个表格或矩阵它由行和列组成在语言中二维数组可以使用两个索引或者叫下标来访问和操作数组中的元素一个索引或者叫下标表示行另一个索引或者叫下标表示列二维数组的定义二维数组的定义形式数据类型数组名行数列数数据类型表示数组中元素的数据类型数组名是一个标识符用于表示数组的名称行数表示二维数组的行数列数表示二维数组的列数定义一个包含行列的二维数组的语句如下二维数组的初始化静态初始化在定义时就定义了所有数据将所有数据写在同一花括号内系统按照下标自动自动分配行列两者均表示一个意思只对部分元素赋值未赋值的元素自动赋值为这样表示的定义时可以对第一维不指定但第二维必须指定等价于第二维为三总共有个数据所以第一维自然为二二维数组的访问在语言中可以使用索引或者叫下标来访问数组中的元素数组的索引或者叫下标从开始递增表示数组中元素的位置访问数组元素的方式为数组名索引索引初始化一个包含行列的二维数组的语句如下二维数组中的元素可以通过两个索引来访问和操作第一个索引表示行第二个索引表示列索引从开始递增表示数组中元素的位置例如访问二维数组中的第行第列的元素的语句如下表示二维数组中的第行第列的元素需要注意的是二维数组的行数和列数是固定的一旦定义后就不能改变如果需要存储更多的元素可以重新定义一个更大行数和列数的二维数组并将原数组中的元素复制到新数组中二维数组以上的多维数组同理大差不错添加结束字符表示字符串结束马上就讲到字符数组字符串变量它有容量为个字符接下来通过到分别赋值为字符这样就形成了一个字符串语言数组的索引是从开始的所以表示数组中的第一个元素即字符串的第一个字符每个字符都用单引号括起来字符数组的初始化静态初始化直接定义好再一一配队两者同一个意思大括号内的值按照顺序依次赋给数组中的元素如果数组的长度小于大括号内的元素个数会产生编译错误如果数组的长度大于大括号内的元素个数则剩余的元素会被自动初始化为字符数组的访问访问字符数组时可以使用索引来访问数组中的每个字符索引从开始递增到数组长度减示例访问单个字符获取第一个字符第一个字符修改单个字符将第一个字符修改为修改后的字符串输出遍历字符数组计算字符数组的长度字符数组长度输出在上面的示例中我们首先通过索引来访问字符数组中的单个字符通过使用我们可以获取第一个字符然后我们将的值修改为从而将第一个字符改为小写接下来我们使用一个循环来遍历整个字符数组我们通过计算字符数组的长度使用运算符来确定循环的终止条件需要注意的是我们减去是为了避免访问到字符串的结束标志在循环中我们使用索引来访问字符数组中的每个字符并使用函数打印出来最终我们得到了字符数组中的每个字符字符串和字符串结束标志字符串结束标志语言规定以字符作为结束标志如果字符数组中存在若干个字符前面个字符都不是空字符而第个字符是则认为数组中有一个字符串其有效字符为个意为在遇到字符时表示字符串结束把它前面的字符组成一个字符串了解语言字符串处理后字符数组初始化方法可以多一种字符串常量字符数组初始化同理字符数组的输入输出逐个字符输入输出用格式符请输入一个字符串将换行符替换为字符串结束符输入的字符串为逐个字符输出字符串输出请输入一个字符串输入的字符串为逐个字符输出字符串将整个字符串一次性输入输出用格式符请输入一个字符串输入的字符串为输出请输入一个字符串输入的字符串为字符串处理函数函数输出字符串函数将一个字符串以结束的字符序列输出到终端输出同时函数输出的字符串可以包含转义字输出在用输出时将字符串结束标志转换成即输出完字符串后换行函数输入字符串函数从终端输入一个字符串到字符数组并且得到一个返回值返回值如果成功返回输入的字符串如果发生错误或到达文件结束返回假定输入输出对于输入由于最后的换行符也会被存储在数组中所以实际上是存储了个字符和换行符函数字符串连接函数一般形式字符数组字符数组把字符串连接到字符串的后面示例输出函数字符串复制函数函数一般形式字符数组字符数组将字符串复制到字符串中去示例输出函数函数用于将一个字符串的指定长度复制到另一个字符串中一般形式字符串字符串要复制的字符数函数会将源字符串的指定长度的字符复制到目标字符串中如果源字符串的长度小于指定的字符数则目标字符串将以结束符填充到指定字符数如果源字符串的长度大于指定的字符数则目标字符串将不会以结束符结尾需要注意的是函数不会自动在目标字符串的末尾添加结束符因此在使用函数后需要手动将结束符添加到目标字符串的末尾示例手动添加结束符输出结果为在这个示例中我们定义了一个长度为的字符数组并初始化为空字符串我们还定义了一个字符数组并初始化为使用函数将字符串的前个字符复制到字符串中由于指定了目标字符串的最大长度为函数复制了字符串的前个字符到字符串中但没有添加结束符因此我们需要手动将结束符添加到字符串的最后最后通过函数打印字符串输出结果为函数字符串比较函数一般形式字符串字符串比较字符串和字符串例如比较规则将两字符串自左至右逐个字符相比按码值大小比较直到出现不同的字符或遇到为止如全部字符相同则认为两字符串相等若出现不相同的字符则以第对不相同的字符的比较结果为准比较的结果由函数值带回如字符串与字符串相同则函数值为如字符串字符串则函数值为一个正整数如字符串字符串则函数值为一个负整数函数测字符串长度的函数一般形式字符数组函数的值为字符串中的实际长度不包括在内输出的结果不是也不是而是函数转换为大写的函数一般形式字符串其函数的作用是将字符串中大写字母换成小写字母函数转换为大写的函数一般形式字符串其函数的作用是将字符串中小写字母换成大写字母第章用函数实现模块化程序设计为什么要用函数模块化程序设计的思路模块化程序设计的思路是将一个复杂的程序拆分成独立的可重用的模块每个模块负责实现一个特定的功能或完成一个具体的任务例如用函数实现求一个数的正弦值需要用时直接在程序中写上来调用系统函数库中的函数代码执行这些代码得到结果好处语言中模块化程序设计可以使代码结构更清晰减少代码的复杂性提高代码的复用性方便调试和测试并且提高代码的可维护性定义函数语言要求在程序中用到的所有函数必须先定义后使用定义函数的规则指定函数的名字以便以后按名调用指定函数的定义即函数返回值的类型指定函数的参数的名字和类型以便在调用函数时向它们传递数据对无参函数不需要这个指定函数应当完成什么操作即函数的功能定义函数的方法定义无参函数函数名后面的括号中是空的没有任何参数一般形式类型名函数名函数体或者类型名函数名函数体示例调用函数只会输出定义有参函数函数名后面的括号中就有了形参形式参数表列一般形式类型名函数名形参函数体定义空函数程序设计中有时会用到一般形式类型名函数名空函数在初学者学习编程的过程中可能没有太多直接的用途因为它们没有实际完成任何具体的操作或功能然而空函数在编程中仍然有一些可以帮助初学者的用途框架搭建在程序的早期阶段可以使用空函数作为某个功能的占位符这样你可以在函数的基础上构建程序的其他部分并在后续逐步填充具体的功能接口一致性在学习面向对象编程时接口是一种规定了类中公共方法的方式如果你正在实现一个接口并且某个方法对于你来说暂时没有具体的实现逻辑你可以将其定义为空函数这样你可以确保你的代码与接口的规范保持一致然后逐步实现其他相关功能调试与测试在调试或测试过程中你可能需要模拟某个函数的行为而不需要实际执行任何操作你可以将该函数定义为空函数以便在调试和测试过程中临时禁用该函数的功能调用函数一般形式函数名实参列表如果是调用无参列表则实参列表可以没有但括号不能省略如果实参列表包含多个实参则各参数间用逗号隔开函数调用的种形式函数调用语句把函数调用单独作为一个语句函数表达式是表达式的一部分来参与表达式的运算求出之间的最大值再与进行计算函数参数函数调用作为另一个函数调用时的参数函数调用时的数据传递形式参数和实际参数形式参数再定义函数时函数名后面括号中的变量名称为形式参数简称形参或虚拟参数实际参数再主调函数中调用一个函数时函数名后面括号中的参数称为实际参数简称实参使用形式参数和实际参数的代码示例定义一个函数使用形式参数调用函数传递实际参数定义了一个函数它接受一个整数形式参数在函数中我们声明了一个整数变量并赋值为然后调用函数并将作为实际参数传递给该函数在函数调用过程中实际参数的值被复制到形式参数中在函数内部我们可以使用形式参数来访问并打印传递的实际参数的值输出结果为在这个例子中形式参数是函数的虚拟参数它在函数定义时被声明而实际参数是在调用函数时传递给函数的真实数据实参和形参间的数据传递再调用函数过程中系统会把实参的值传递给被调用函数的形参或者说形参从实参得到一个值该值再函数调用期间有效可以参加该函数中的运算使用实参传递给形参的语言代码示例定义一个函数使用形式参数进行运算调用函数将和作为实际参数传递定义了一个函数它接受两个整数形式参数和在函数中我们声明了两个整数变量和并分别赋值为和然后我们调用函数并将和作为实际参数传递给该函数在函数调用过程中实际参数和的值被传递给形式参数和在函数内部我们使用形式参数和进行加法运算并将结果保存在变量中最后我们将作为返回值返回给调用者在函数中我们将函数的返回值保存在变量中并打印出来输出结果为在例子中实参和的值被传递给形参和形参在函数调用期间有效并参与了函数内部的加法运算最后函数的返回值被传递给了变量函数调用的过程在定义函数中指定的形参在未出现函数调用时它们并不占用内存中的储存单元在发生函数调用时函数的形参才被临时分配内存单元将实参的值传递给对应形参让形参得到实参的值在执行函数期间由于形参已经有值就可以利用形参进行有关的运算通过语句后面会讲将函数值带回到主调函数执行语句就把这个函数返回值带回主调函数注意返回值的类型应与函数类型一致如果函数不需要返回值则不需要语句这时函数应该是类型调用结束形参单元被释放但实参单元仍保留并维持原值没变如果在执行一个被调用函数时形参的值发生改变不会改变主调函数的实参值示例函数定义计算两个整数的和函数调用将和作为实参传递给函数打印结果在上面的代码中首先定义了一个函数该函数接受两个整数作为参数并返回它们的和然后在函数中声明了两个整数变量和并将它们作为实参传递给函数进行调用调用结束后将返回的结果赋值给变量并通过函数打印出来执行上述代码输出结果为说明函数调用和返回值传递的过程是正确的函数的返回值希望通过函数调用时主调函数能得到一个确定的值这就是函数值函数的返回值函数的返回值是通过函数中的语句获得的函数值的类型在定义函数时指定的函数类型一般应该和语句中的表达式类型一致代码示例演示了函数的返回值的获取和类型的一致性函数定义计算两个整数的和函数定义计算两个浮点数的平均值函数调用将和作为实参传递给函数并获取返回值打印结果函数调用将和作为实参传递给函数并获取返回值打印结果在上面的代码中定义了两个函数和分别用于计算整数的和和浮点数的平均值在函数中分别调用了这两个函数并通过语句获取了它们的返回值注意函数返回的是类型的值而函数返回的是类型的值执行上述代码输出结果为说明函数的返回值获取和类型的一致性是正确的函数递归该知识点难理解强烈建议结合例子习题理解语言允许在调用一个函数的过程中有出现直接或间接地调用该函数本身这种行为称为函数的递归调用在语言中函数递归的实现需要满足以下几个要点基本情况递归终止条件递归函数必须包含一个或多个基本情况即递归终止条件这些条件表示递归函数不再继续调用自身而是直接返回一个结果没有递归终止条件的递归函数将会无限循环调用自身导致栈溢出递归调用在递归函数的定义中通过调用自身来解决规模更小的子问题递归调用应该在满足递归终止条件的情况下进行以避免无限递归问题规模的缩小递归函数应该在每次调用自身时通过改变输入参数的值来缩小问题的规模这样每次递归调用都在解决一个规模更小的子问题下面是一个经典的递归函数示例用于计算阶乘递归函数计算阶乘基本情况当为或时直接返回递归调用将问题规模缩小计算的阶乘需要先计算的阶乘调用递归函数计算阶乘设置中文环境打印结果的阶乘是在上面的代码中定义了一个递归函数用于计算一个整数的阶乘在函数中首先判断输入的整数是否为或如果是则直接返回作为递归终止条件否则通过递归调用自身将问题规模缩小为计算的阶乘并将结果乘以最终得到的阶乘在函数中我们使用函数将程序的本地化环境设置为中文环境以支持中文输出然后使用函数来输出中文字符串其中的前缀表示宽字符字符串执行上述代码输出结果为的阶乘是说明递归函数成功地计算了的阶乘需要注意的是在实际应用中递归函数可能会因为递归的深度过大而导致栈溢出因此在设计递归函数时需要注意递归的终止条件和问题规模的缩小以避免出现问题数组作为函数参数数组元素也可以用作函数实参用法与变量一致向形参传递数组元素的值此外数组名也可以作实参和形参传递的事数组第一个元素的地址数组元素作函数参数数组元素可以用作函数实参但是不能用作形参因为形参是在函数被调用时临时分配储存单元的不可能作为一个数组元素单独分配储存单元数组是一个整体在内存中占连续的一段储存单元在用数组元素作函数实参时把实参的值传给形参是值传递方式数据传递的方向是从实参传到形参单向传递示例调用函数前调用函数后在上面的例子中我们定义了一个数组并将其第一个元素传递给函数函数将形参的值改为然而在函数调用结束后数组的第一个元素的值并没有改变这是因为在函数调用时只是将数组元素的值传递给了函数的形参而不是直接传递数组元素本身因此对形参的修改不会影响到原始数组输出结果总结数组元素可以作为函数实参传递给函数但是不能作为函数形参函数对数组元素的修改不会影响到原始数组一维数组名作函数参数除了可以用数组元素作为函数参数外还可以用数组名作函数参数包括实参和形参注意用数组元素作实参时向形参变量传递的事数组元素的值而用数组名作函数实参时向形参数组名或指针变量传递的事数组首元素的地址示例调用函数前调用函数后在上面的例子中我们定义了两个函数和函数用于打印数组的元素接受一个整数数组和数组大小作为参数函数用于将数组的每个元素乘以同样接受一个整数数组和数组大小作为参数在函数中我们声明了一个大小为的整数数组并将其初始化为首先我们调用函数打印数组的元素然后调用函数修改数组的元素最后我们再次调用函数打印修改后的数组元素在函数调用时我们将数组名作为实参传递给了函数的形参即和由于数组名传递的是数组首元素的地址函数在接收到数组名后可以通过指针的方式访问数组的元素并对其进行操作输出结果调用函数前调用函数后局部变量和全局变量定义变量可能有种情况在函数的开头定义在函数内的复合语句内定义在函数的外部定义作用域在一个函数中定义的变量在其他函数中能否被引用在不同位置定义的变量在什么范围内有有效这就是变量的作用域的问题每个变量都有一个作用域问题即它们在什么范围内有效变量的作用域从空间的角度来观察可分为全局变量和局部变量局部变量局部变量是在函数或者语句块内部定义的变量它的作用域仅限于定义它的函数或者语句块内部局部变量在函数或者语句块执行结束后会被销毁其占用的内存空间也会被释放例如下面是一个定义局部变量的示例定义一个局部变量赋值给输出的值在上面的示例中是一个局部变量它只在函数内部有效当函数执行完毕后变量会被销毁局部变量的作用域仅限于定义它的函数或者语句块内部这意味着在其他函数或者语句块中无法访问到局部变量例如在上面的示例中如果在函数中尝试访问变量会导致编译错误局部变量的生命周期与其作用域相对应当程序执行到定义局部变量的语句时会为变量分配内存空间当变量的作用域结束时会释放该内存空间全局变量全局变量是在函数外部定义的变量它的作用域从定义点开始直到文件结束全局变量可以在整个程序中被访问和使用在语言中全局变量的定义通常在所有函数的外部即在函数之外全局变量的定义可以在任何函数之前但是只能定义一次例如下面是一个定义全局变量的示例定义一个全局变量在函数内部访问和修改全局变量输出全局变量的值在上面的示例中是一个全局变量它可以在函数内部访问和修改全局变量的值在整个程序中都是可见的全局变量的作用域从定义点开始直到文件结束这意味着在整个程序中的任何函数中都可以访问和使用全局变量例如在上面的示例中如果在函数中尝试访问全局变量是完全合法的全局变量的生命周期与整个程序的运行时间相对应当程序开始执行时会为全局变量分配内存空间当程序结束时会释放该内存空间变量的存储方式和生存期变量的作用域从存在的时间即生存期来观察可分为静态存储方式动态存储方式静态动态存储方式静态存储方式是指在程序运行期间由系统分配固定的存储空间的方式动态存储方式是在程序运行期间根据需要进行动态的分配存储空间的方式在内存中的供用户使用的存储空间可分为三部分程序区静态存储区动态存储区数据分别放在静态存储区和动态存储区中全局变量全部存放在静态存储区中在程序开始执行时给全局变量分配存储区程序执行完毕就释放在程序执行过程中它们占据固定的存储单元而不是动态地进行分配和释放在动态存储区中存放以下数据函数形式参数在调用函数时给形参分配存储单元函数中定义的没有用关键字声明的变量即自动变量后面马上讲函数调用时的现场保护和返回地址等局部变量的存储类别在定义和声明变量和函数时一般应同时指定其数据类型和存储类别也可以采用默认方式指定就是用户不指定系统会隐含地指定为某一种存储类别根据变量的存储类别可以知道变量的作用域和生存区语言的存储变量分为自动变量静态变量寄存器变量外部变量局部变量分为以下三种自动变量变量在函数中的局部变量如果不专门声明为静态存储类别都是动态的分配存储空间的数据存储在动态存储区中函数中的形参和在函数中定义的局部变量包括在复合语句中定义的局部变量都属于此类调用该函数时系统会给这些变量分配储存空间在函数调用结束时就自动释放这些存储空间因此这类局部变量称为自动变量实际上关键字可以省略不写则隐含指定为自动存储类别它属于动态存储方式静态局部变量局部变量有时希望函数中的局部变量的值在函数调用结束后不消失而继续保留原值其占用的储存单元不释放在下一次在调用该函数时该变量已有值就是上一次调用结束时的值此类局部变量叫静态局部变量静态局部变量输出输出输出在上面的代码中函数内部定义了一个静态局部变量并初始化为每次调用函数时的值都会自增并通过函数打印出来由于是静态局部变量它的值在函数调用之间保持不变即使函数被多次调用的值也会保持累加因此上述代码的输出结果将是寄存器变量变量一般地变量包括静态存储方式和动态存储方式的值是存放在内存中的如果有一些变量使用频繁为提高执行效率允许将局部变量的值存放在中的寄存器中需要用时直接从寄存器取出参加运算不必再到内存中去存取以提高执行效率这种变量叫做寄存器变量实际上使用不多知道有这种类别即可全局变量存储类别全局变量都是存放在静态存储区中的因此它们的生存期是固定的存在于程序的整个运行过程在一个文件内拓展外部变量的作用域如果外部变量不在文件的开头定义其有效地作用范围值限于定义处到文件结束在定义点之前的函数不能引用该外部变量如果由于某种考虑在定义之前的函数需要引用该外部变量则应该在应用之前用关键字对该变量作外部变量声明表示把该外部变量的作用域扩展到此位置有了此声明就可以从声明处起合法地使用外部变量下面是一个简单的语言代码例子展示了如何使用关键字声明变量和函数在文件中定义全局变量定义全局变量声明函数调用函数打印全局变量的值在文件中使用关键字声明变量并定义函数使用关键字声明全局变量打印全局变量的值修改全局变量的值在上述代码中文件中定义了一个全局变量并声明了函数文件中使用关键字声明了变量并定义了函数在文件的函数中首先调用了函数然后打印了全局变量的值在函数中打印了全局变量的值并修改了其值为在编译和链接这两个文件时编译器会在链接阶段把文件中的变量和函数与文件中的引用关联起来从而实现了在不同文件中共享变量和函数的功能将外部变量的作用域拓展找其他文件在文件中定义外部变量定义外部变量打印外部变量的值在文件中使用关键字引用外部变量使用关键字引用外部变量打印外部变量的值修改外部变量的值在上述代码中文件中定义了一个外部变量并在函数中打印了外部变量的值文件中使用关键字引用了外部变量并在函数中打印了外部变量的值并修改了其值为在编译和链接这两个文件时编译器会在链接阶段将文件中的引用与文件中的定义关联起来从而实现了在不同文件中共享外部变量的功能外部函数与内部函数内部函数如果一个函数只能被本文件其他函数所调用它称为内部函数在定义内部函数时在函数名和函数类型的前面加即可类型名函数名形参表例如函数的首行表示是一个内部函数不能被其他文件调用内部函数又称静态函数因为它是用声明的使用内部函数可以使函数的作用域只局限于所在文件这样在不同的文件中即使有同名的内部函数也互不干扰不必担心所用函数是否会与其他文件模块中的函数同名外部函数如果在定义函数时在函数首部的最左段加关键字则此函数时外部函数可供其他文件调用语言规定如果在定义函数时省略则默认为外部函数第章善于利用指针本章节是语言的重难点多看多练指针的含义数据在内存中的存储与读取在程序中定义了一个变量在对程序进行编译时系统给这个变量分配内存单元不同变量分配不同长度空间在中整型变量分配个字节双精度浮点型变量也分配个字节内存区的每一个字节有一个编号这就是地址相当与酒店里的房间号在地址所标志的内存单元中存放的数据则是相当于酒店房间中居住的旅客由于通过地址能找到所需的变量单元即为地址指向该变量单元把地址形象化地称为指针能找到以它为地址的内存单元直接访问与间接访问直接访问直接访问是指直接使用变量名来访问变量的值例如定义了一个整型变量我们可以直接使用来访问和修改它的值间接访问间接访问是通过指针来访问变量的值指针存储了一个变量的地址通过指针我们可以间接地访问和修改该地址处的数据例如符号后面马上讲到将整型变量的地址赋值给指针变量然后我们可以使用来访问和修改的值举例为将数值送到变量中有两种表达方式将直接送到变量所标识的单元中如将送到变量所指向的单元即变量的存储单元如其中表示指向的对象指向就是通过地址来体现的由于通过地址能找到所需的变量单元因此说地址指向该变量单元如房间号指向或代表着一个房间一样将地址形象化地称为指针指针变量如果有一个变量专门来存放另一变量的地址即指针则它称为指针变量指针变量就是地址变量用来存放地址指针变量的值就是地址定义指针变量类型名指针变量名的位置无所谓靠左靠右在中间都行上例左端的是在定义指针变量时必须指定的基类型用来指定次指针变量可以指向的变量的类型如上例只能用于指向整型引用指针变量给指针变量赋值定义了一个整型变量并赋值为然后定义了一个整型指针并将的地址赋给这样就指向了的内存地址符号在语言中表示取地址操作符它用于获取变量的内存地址在这段代码中表示获取变量的内存地址并将该地址赋给指针变量引用指针变量指向的变量有最终的输出结果为首先定义了一个整型变量并赋值为然后定义了一个整型指针并将的地址赋给接下来使用函数来输出变量的值第一行语句中使用了解引用操作符即表示获取指针指向的地址的值所以输出的结果为第二行语句中直接输出变量的值也是如果有表示将整数赋值给当前所指向的变量如果指向则相当于把赋值给引用指针变量的值作用是以八进制数形式输出指针变量的值如果指向了就是输出了的地址即指针变量作为函数参数函数的参数不仅可以是整型浮点型字符型的数据还可以是指针类型它的作用是将一个变量的地址传送到另一个函数中下面是一个使用指针变量作为函数参数的语言代码例子函数原型参数为指针变量函数调用前的值调用函数传入指针变量的地址函数调用后的值函数定义通过指针修改变量的值解引用指针修改变量的值在这个例子中我们定义了一个函数它接受一个指针变量作为参数在函数中我们定义了一个整型变量并赋值为然后我们调用函数并传入的地址作为参数在函数中我们通过解引用指针来修改变量的值最后在函数中打印修改后的的值输出结果为函数调用前的值函数调用后的值可以看到通过指针变量作为函数参数我们可以在函数内部修改变量的值并且这个修改也会影响到函数外部的变量指针引用数组数组元素的指针一个变量有地址一个数组包含若干个元素每个数组元素都在内存中占有存储单元他们都有相应的地址指针变量既然可以指向变量当然也可以指向数组元素可以用一个指针变量指向一个数组元素首先定义了一个整型数组并初始化为然后声明了一个整型指针变量接下来将数组的第一个元素的地址在语言中数组名不算形参数组名代表数组中首元素如的地址因此下面两者是等价的设定是数组名是指针变量在引用数组元素时的指针运算在指针以指向一个元素时可以对指针进行以下运算在引用数组元素时可以对指针进行一些运算操作下面是一些常见的指针运算加一个整数可以使用指针加上一个整数来访问数组中的下一个元素例如会将指针向后移动一个位置指向数组中的下一个元素减一个整数类似地可以使用指针减去一个整数来访问数组中的前一个元素例如会将指针向前移动一个位置指向数组中的前一个元素自增运算可以使用自增运算符来将指针向后移动一个位置例如或会将指针指向数组中的下一个元素自减运算类似地可以使用自减运算符来将指针向前移动一个位置例如或会将指针指向数组中的前一个元素两个指针相减当两个指针指向同一数组中的元素时可以使用减法运算符来计算它们之间的距离以元素个数为单位例如会得到两个指针之间的元素个数需要注意的是只有在指针指向同一数组中的元素时才能进行指针的加减运算和两个指针的相减运算否则结果将是未定义的通过指针引用数组元素引用数组元素可以用下标法也可以用指针法及通过指向数组元素的指针找到所需元素下面是使用语言代码通过指针引用数组元素的两种方法下标法和指针法嗯下标法在这个例子中使用了一个循环来遍历数组通过下标来访问数组元素即通过循环迭代可以依次引用数组中的每个元素指针法在这个例子中定义了一个整型指针变量并将其初始化为指向数组的第一个元素的地址即然后使用循环来遍历数组通过指针来引用数组元素即在每次循环迭代中指针向后移动一个位置指向下一个数组元素指针引用字符串字符串的引用方式在语言中字符串可以通过两种方式进行引用作为字符数组和作为字符指针字符数组方式引用字符串字符数组方式引用字符串在这个例子中使用字符数组来引用字符串字符数组会在内存中分配足够的空间来存储字符串的每个字符字符串的末尾会自动添加一个空字符作为结束符字符指针方式引用字符串字符指针方式引用字符串在这个例子中使用字符指针来引用字符串字符指针指向字符串的第一个字符字符串的末尾仍然有一个空字符作为结束符需要注意的是字符数组方式引用字符串可以修改字符串的内容而字符指针方式引用字符串不能修改字符串的内容例如下面的代码会导致编译错误编译错误字符指针方式引用的字符串是只读的字符指针作函数参数在语言中可以使用字符指针作为函数的参数来传递字符串通过传递字符指针函数可以访问并操作字符串的内容下面是一个例子演示了如何使用字符指针作为函数参数来打印字符串在这个例子中定义了一个函数它接受一个字符指针参数并使用函数打印字符串在函数中定义了一个字符指针并将其作为参数传递给函数需要注意的是字符指针作为函数参数传递时函数内部不能修改指针的值也不能修改指针所指向的字符串的内容如果需要在函数内部修改字符串的内容可以使用字符数组作为函数参数指向函数的指针函数的指针在程序中定义了一个函数在编译时会把函数的源代码转换为可执行代码并分配一段存储空间这段存储空间有一个起始地址也称为函数的入口地址每次调用函数时都从该地址入口开始执行此段函数代码函数名代表函数的起始地址函数名就是函数的指针它代表函数的起止地址定义是一个指向函数的指针变量可以指向函数类型为整型且有两个整型参数的函数用函数指针变量调用函数要使用函数指针变量调用函数可以直接使用函数指针变量的名称后跟括号类似于调用函数的语法下面是一个示例代码演示了如何使用函数指针变量调用函数声明一个指向函数的指针变量将函数的地址赋值给函数指针变量通过函数指针调用函数可以将函数指针指向不同的函数再次通过函数指针调用函数在这个例子中我们定义了两个函数和它们分别接受两个整数参数并返回整数然后我们声明了一个指向函数的指针变量它接受两个整数参数并返回整数我们将函数的地址赋值给然后通过调用函数并将结果存储在变量中接着我们将函数的地址赋值给再次通过调用函数并将结果存储在变量中定义和使用指向函数的指针变量定义指向函数的指针变量返回类型指针变量名参数类型参数类型下面是一个示例代码演示了如何定义和使用指向函数的指针变量声明一个指向函数的指针变量将函数的地址赋值给函数指针变量使用函数指针调用函数函数的结果将函数的地址赋值给函数指针变量使用函数指针调用函数函数的结果在这个例子中我们定义了两个函数和它们分别接受两个整数参数并返回整数然后我们声明了一个指向函数的指针变量它接受两个整数参数并返回整数我们将函数的地址赋值给然后通过调用函数并将结果存储在变量中接着我们将函数的地址赋值给再次通过调用函数并将结果存储在变量中动态内存分配在语言中动态内存分配是通过和函数来实现的这些函数可以帮助我们在程序运行时动态地分配和释放内存函数用于分配指定字节数的内存并返回一个指向分配内存的指针它的基本用法如下内存分配失败使用分配的内存函数与函数类似但它会将分配的内存块的每个字节都初始化为零它的基本用法如下内存分配失败使用分配的内存函数用于重新分配已经分配的内存块的大小如果原内存块的大小不够函数会重新分配更大的内存块并将原内存块的内容复制到新内存块中如果原内存块的大小过大函数会缩小内存块的大小它的基本用法如下内存分配失败使用分配的内存重新分配内存块的大小为个整数内存重新分配失败使用重新分配的内存函数用于释放之前通过或函数分配的内存它的基本用法如下内存分配失败使用分配的内存需要注意的是动态分配的内存需要手动释放否则会导致内存泄漏在释放内存后不能再使用已释放的内存否则会导致未定义的行为第章用户自己建立数据类型结构体变量结构体定义结构体由多个成员变量组成每个成员变量可以是不同的数据类型通过结构体我们可以将相关的数据组织在一起方便管理和操作结构体的定义使用关键字后面跟着结构体的名称和成员变量的列表结构体的定义结构体名成员列表在上面的例子中我们定义了一个名为的结构体它有三个成员变量和是一个字符数组用于存储学生的姓名是一个整数用于存储学生的年龄是一个浮点数用于存储学生的平均成绩结构体成员变量的运用定义一个结构体类型声明一个结构体变量并初始化访问结构体成员变量并输出学生学生姓名学生年龄修改结构体成员变量的值输出修改后的结果学生年龄修改后我们可以通过结构体的名称和成员变量的名称来访问结构体的成员例如下面是一个使用结构体的例子设置学生的信息打印学生的信息姓名年龄平均成绩在上面的例子中我们首先定义了一个名为的结构体变量然后我们使用运算符来访问结构体的成员变量并设置其值最后我们打印了学生的姓名年龄和平均成绩关键字关键字是语言中用来给已经存在的数据类型起一个新的名字的关键字通过使用关键字可以为已有的数据类型定义一个新的名称使得使用该数据类型时更加方便和直观关键字通常与结构体一起使用用于给结构体类型定义一个新的名称关键字的语法格式如下原类型名新类型名例如可以使用关键字为结构体类型定义一个新的名称如下所示在上述示例中使用关键字为结构体类型定义了一个新的名称之后可以直接使用作为结构体类型的名称而不需要每次都使用关键字定义结构体类型变量当我们定义结构体类型变量时可以使用种方法先声明结构体类型在定义该类型的变量先声明结构体类型再定义结构体变量姓名年龄平均成绩在上面的例子中我们首先使用关键字声明了一个名为的结构体类型然后在函数中我们定义了一个名为的结构体变量该变量的类型是之前声明的结构体类型在声明类型的同时定义变量就是将结构体的声明和初始化合并在一起示例声明结构体类型的同时定义结构体变量定义并初始化结构体变量使用已定义的结构体变量坐标点在示例中我们定义了一个结构体类型其中包含两个整型成员变量和而在结构体类型的声明之后我们紧接着定义了一个结构体变量并使用初始化列表对其成员变量进行了赋值不指定类型名而直接定义结构体类型变量可以通过使用匿名结构体类型直接定义结构体类型变量而不需要指定类型名这样的结构体类型被称为匿名结构体示例直接定义匿名结构体类型的变量定义并初始化匿名结构体变量使用已定义的匿名结构体变量坐标点在示例中我们没有显式地声明一个具名的结构体类型而是直接定义了一个匿名的结构体类型并创建了一个匿名结构体变量同样我们也可以在定义时使用初始化列表对其成员变量进行赋值值得注意的是匿名结构体类型仅在定义它的作用域内有效这意味着我们无法在其他位置复用或引用这个结构体类型也不能通过为其定义一个类型名结构体类型数组名数组长度结构体数组的应用常规结构体数组应用的示例假设我们要管理学生信息输入学生信息请输入学生的信息姓名年龄输出学生信息学生的信息姓名年龄这个示例中我们定义了一个名为的结构体类型其中包含了学生的姓名年龄和平均绩点信息在函数中我们声明了一个名为的结构体数组数组长度为然后我们使用一个循环来输入每个学生的详细信息并将其存储到对应的结构体数组元素中最后我们再次使用循环遍历结构体数组并输出每个学生的详细信息运行该程序你将被要求依次输入每个学生的姓名年龄和然后程序将输出输入的学生信息结构体指针如果把一个结构体变量的起始地址存放在一个指针变量中这个指针变量就指向该结构体变量两种不同的访问结构体成员的方式点操作符使用点操作符可以直接访问结构体变量的成员这种方式适用于直接访问结构体变量例如箭头操作符当使用指针指向结构体变量时需要使用箭头操作符来访问结构体变量的成员这种方式适用于访问结构体指针指向的结构体变量例如注意只有当我们使用指针指向结构体变量时才需要使用箭头操作符如果我们直接使用结构体变量则应使用点操作符指向结构体变量数组的指针指向结构体对象指着变量即可指向结构体变量也可指向结构体数组中的元素指针变量的基类型必须与结构体变量的类型相同可以指向类型的变量或数组元素指向结构体变量的指针在这个例子中我们定义了一个结构体类型并创建了一个结构体变量然后我们定义了一个指向类型的指针并将其指向结构体变量通过指针我们可以访问结构体变量的成员指向结构体数组中元素的指针在这个例子中我们定义了一个包含三个元素的结构体数组然后我们定义了一个指向类型的指针并将其指向结构体数组的第一个元素通过指针可以访问结构体数组中的元素并通过和可以访问数组的下一个元素结构体变量的指针作函数参数当我们想要在函数中修改结构体变量的值时可以通过将结构体变量的指针作为函数的参数传递从而达到修改结构体变量的目的示例输出输出在上面的示例中我们定义了一个结构体类型并在函数中接受一个类型的指针作为参数在函数中通过箭头操作符修改了指针指向的结构体变量的成员值在函数中我们创建了一个类型的结构体变量然后通过将的地址作为参数传递给函数在函数调用后的成员值被修改为和所以通过将结构体变量的指针作为函数参数我们可以在函数中直接修改结构体变量的值指针处理链表该章节所涉及的链表均为单链表链表定义链表单向链表是一种常见的数据结构用于存储和组织数据链表开头有一个头指针变量存放一个地址该地址指向一个元素链表末尾有一个尾指针变量存放表示空地址链表到此结束除了头尾指针外链表中每一个元素称为结点每个结点包括两部分数据域用户需要用的实际数据上图中的指针域下一个结点的地址从上例得知指向第个元素第个元素又指向第个元素直到最后一个元素该元素不在指向其他元素只存放一个空地址链表结束链表中的各元素在内存中的地址可以是不连续的要找某一元素必须先找到上一个元素根据他提供的下一个地址才能找到下一个元素如果不提供头指针则整个链表都无法访问语言表示链表链表这种数据结构显然是指针加结构体最合适定义单链表的节点结构体数据指向下一个节点的指针上述代码定义了一个单链表的节点结构体它包含两个成员变量用于存储节点的数据用于指向下一个节点的指针它是一个指针类型的成员变量指向类型的节点通过这个节点结构体我们可以创建单链表的节点并使用成员变量存储节点的数据使用成员变量指向下一个节点建立简单的静态列表通过一个例子来说明如何建立和输出一个简单链表声明结构体类型定义个结构体变量和结构体指针变量分别对结构体变量赋值结点的起始地址赋值给头指针结点的起始地址赋值给结点的成员结点的起始地址赋值给结点的成员结点的被赋值表示不存放任何结点地址使指向头指针上面的代码定义了一个结构体类型它包含三个成员变量用于存储学生的学号用于存储学生的分数用于指向下一个学生节点的指针这里使用了自引用的方式使得可以构建出一个链表结构在函数中首先建了三个结构体变量和并给它们分别赋值表示三个学生的学号和分数然后通过将和分别赋值为和将这三个节点串联成一个链表头指针被赋值为即指向链表的第一个节点然后定义了一个指针变量将它初始化为接下来使用循环遍历链表并打印每个节点的学号和分数这里使用函数打印输出最后返回表示程序执行成功结束运行上述代码输出结果为建立动态链表所谓动态链表是指在程序执行过程中从无到有地建立起一个链表即一个一个地开辟结点和输入各结点数据并建立起前后相连的关系给取别名创建一个单链表模板数据域指针域指向下一个相邻的单链表创建一个空的单链表由指向它即头结点带头结点数据域没有值指针域为空括号内为指针变量的引用不看就是普通变量加上就是指针变量销毁线性表单链表的头结点传给指向着的下一个单链表只要不指向尾结点就一直重复每动一步就释放指向的一个数据结点的空间即销毁了一个数据结点再让指向下一个数据结点也就是所指向的紧接着移动指向下下一个数据结点已经指向了尾结点释放指向的最后一个的数据结点做到销毁整个单链表求线性表的长度该单链表的头结点让指向指向的该单链表的首结点因为只计算除头尾结点之外的数据结点的长度只要不指向尾结点就一直执行记录长度让指向下一个数据结点记录结束返回的值即该单链表的长度求线性表中第个元素该单链表的头结点要找的第个元素位置要找的元素位置上的值为计数从加到第个因为首结点不算所以是加一个数据结点就从头结点开始从数据结点开始让指向指向的该单链表的首结点因为头尾结点数据域没有值判断数字是否合理不指向尾结点且计数不大于等于才能继续下去情况指向尾结点了都没值可用了退出循环情况都等于了到第个位置了退出循环循环结束只要都指向尾结点了就是说没值可用说明没找到否则就是找到了把指向的数据结点的数据域的值传给实时更新主函数的值因为是这个按值查找是第几个位置该单链表的头结点要的找在单链表中什么位置的值看看在什么位置让指向指向的该单链表的首结点设为直接先找第个位置从头结点开始从数据结点开始指向尾结点了证明没有找到否则就是找到了返回第个值插入元素该单链表的头结点插入结点的数据域的值要插入的第个位置从头结点开始从数据结点开始把该单链表的头结点传给判断第个位置是否合理删除元素输出线性表线性表长度第个元素元素是第个元素删除第个元素线性表输出结果线性表长度第个元素元素是第个元素删除第个元素线性表共用体类型共用体是一种特殊的数据类型它允许在相同的内存位置存储不同的数据类型共用体的内存大小取决于其中最大的成员的大小共用体的成员可以是不同的数据类型但是在同一时间只能存储其中的一个成员值当一个成员值被赋值给共用体时其他成员值都会被覆盖共用体的使用可以节省内存空间因为共用体只会占用足够存储最大成员的内存空间然而由于共用体的成员共享同一块内存空间因此对一个成员的修改会影响其他成员的值定义共用体共用体名成员列表变量列表声明类型同时定义变量类型声明与定义变量分开先声明一个类型再将定义为类型的变量共同体类型的引用对于共用体的成员引用应使用共用体变量名和成员名之间的运算符进行引用在上面的示例中我们定义了一个共用体它有三个成员整型浮点型和字符数组在函数中我们声明了一个共用体变量然后通过和来分别访问共用体的不同成员对于共用体的成员访问不需要使用运算符而是直接使用共用体变量名和成员名之间的运算符这是因为共用体的不同成员共享同一块内存空间因此对一个成员的修改会影响其他成员的值在使用共用体时需要确保对共用体的成员的访问是有意义的并且不会引起意外的结果共用体类型数据的特点同一个内存段可以用来存放几种不同类型的成员但在每一瞬间只能存放其中一个成员而不是同时存放几个输出整数输出字符输出实数在代码中将整数值赋给了共用体的整型成员因此会输出整数接下来尝试输出共用体的字符成员由于共用体的不同成员共享同一块内存空间整型成员的值被解释表为字符因此输出字符最后尝试输出共用体的浮点型成员由于共用体的不同成员共享同一块内存空间整型成员的值被解释为浮点数因此输出实数这个例子展示了共用体的一个重要特性不同类型的成员共享同一块内存空间这意味着对一个成员的修改可能会影响其他成员的值在使用共用体时需要小心确保对共用体的成员的访问是有意义的并且不会引起意外的结果可以对共用体变量初始化但初始化表中只能有一个常量不能初始化个成员它们是占用同一个存储单元的正确对第个成员初始化允许对指定的一个成员初始化共用体变量中起作用的成员是最后一次被赋值的成员在对共用体变量中的一个成员赋值后原有变量存储单元中的值就取代输出整数输出字符输出实数枚举类型如果一个变量只用几种可能的值则可以定义为枚举类型所谓枚举就是指把可能的值一一列举出来变量的值只限于列举出来的值的范围内枚举类型定义枚举名枚举元素列表在上面的代码中我们定义了一个名为的枚举类型它包含了一周的所有工作日和周末枚举常量的默认值从开始自增因此的值为的值为以此类推枚举类型定义后我们可以声明枚举类型的变量并将其赋值为枚举常量例如在上面的代码中我们声明了一个名为的枚举类型变量并将其赋值为枚举常量我们还可以通过枚举常量的名称来访问其对应的值例如上述代码将输出因为的值为枚举类型还可以与语句一起使用以便根据枚举变量的值执行相应的操作例如综合案例示例在上面的代码中我们定义了一个枚举类型用于表示一年中的月份每个月份都被赋予一个整数值从开始自增然后我们定义了一个结构体它包含了一个整型的一个枚举类型的和一个整型的在函数中我们声明了一个名为的结构体变量并通过用户输入来初始化其中的成员最后我们调用函数来打印今天的日期该函数接受一个类型的参数并按照的格式打印日期第章对文件的输入输出文件基本知识什么是文件在程序设计中主要用到两种文件程序文件例如源程序文件目标文件可执行文件数据文件文件的内容不是程序而是供程序运营时读写的数据如在程序运行过程中输出到磁盘或其他外部设备的数据或在程序运行过程中供读入的数据如一批学生的成绩数据本章主要讨论的数据文件在以前的章节里所处理的数据的输入输出都是以终端为对象的即从终端的键盘输入数据运行结果输出到终端显示器上实际上常常需要将一些数据输出到磁盘上保存起来以后需要时再从磁盘中输入到计算机内存这就是磁盘文件统一文件处理从操作系统的角度看每一个与主机相连的输入输出设备都看作一个文件操作系统把各种设备都统一作为文件来处理例如终端键盘是输入文件显示屏和打印机是输出文件文件在语言中文件是一种用于存储和读取数据的抽象概念文件可以是磁盘上的实际文件也可以是输入输出设备如键盘显示器的抽象表示文件名一个文件要有一个唯一的文件标识以便用户识别和引用文件标识包括部分文件路径文件名主干文件后缀文件路径表示文件在外部存储设备中的位置文件路径文件名主干文件后缀表示文件存放在盘中的目录下的子目录下面方便起见文件标识常被称为文件名文件缓冲区指的就是系统自动地在内存区为程序中每一个正在使用的文件开辟一个文件缓冲区从内存向磁盘输出数据必须先送到内存中的缓冲区装满缓冲区后才一起送到磁盘去如果从磁盘向计算机读入数据则一次从磁盘文件将一批数据输入到内存缓冲区中充满缓冲区然后再从缓冲区逐个地将数据送到程序数据区给程序变量文件指针类型文件类型指针是语言中用于操作文件的一种指针类型它可以指向一个已经打开的文件通过该指针可以对文件进行读取写入移动指针位置等操作文件类型指针的声明方式如下其中是语言中定义的文件类型是一个指向类型的指针在声明文件类型指针时需要包含头文件该头文件中包含了对文件类型的定义文件类型指针的声明方式与其他指针类型的声明方式相同都是通过在变量名前面加上类型修饰符来声明一个指针变量例如声明了一个名为的文件类型指针变量在声明文件类型指针时可以不进行初始化即不指向任何文件在需要打开文件之前可以将文件类型指针赋值为表示该指针不指向任何有效的文件例如声明了一个名为的文件类型指针变量并将其初始化为需要注意的是文件类型指针只能指向已经打开的文件不能直接指向文件名或文件路径要打开一个文件并将文件类型指针指向该文件需要使用函数打开与关闭文件函数打开数据文件函数调用方式文件名使用文件方式声明了一个名为的文件类型指针并使用函数打开了一个名为的文件打开模式为只读模式使用文件方式上例中的就是使用文件方式的一种文件使用方式含义如果指定文件不存在只读为了输入数据打开一个已存在的文本文件出错只写为了输出数据打开一个文本文件建立新文件追加向文本文件尾添加数据出错只读为了输入数据打开一个二进制文件出错只写为了输出数据打开一个二进制文件建立新文件追加向二进制文件尾添加数据出错读写为了读和写打开一个文本文件出错读写为了读和写建立一个新的文本文件建立新文件读写为了读和写打开一个文本文件出错读写为了读和写打开一个文本文件出错读写为了读和写建立一个新的二进制文件建立新文件读写为读写打开一个二进制文件出错函数关闭文件函数用于关闭一个已打开的文件它的作用和意义如下释放资源当我们打开一个文件时操作系统会为该文件分配一些资源如文件描述符等当我们不再需要该文件时通过调用函数来关闭文件可以释放这些资源以便其他程序或操作系统可以使用它们保存文件在关闭文件之前函数会将文件缓冲区中的数据写入到磁盘上的文件中这样可以确保在关闭文件之后文件中的数据已经被正确保存而不会丢失或损坏刷新缓冲区在关闭文件之前函数会刷新文件缓冲区即将缓冲区中的数据写入到文件中这样可以确保文件中的数据与缓冲区中的数据同步避免数据丢失或不一致的情况需要注意的是如果在关闭文件之后我们仍然尝试对已关闭的文件进行读写操作将会导致未定义的行为因此在关闭文件之后我们应该确保不再对该文件进行任何操作和函数以不同的方式打开和关闭文件使用模式打开文件以只读方式打开无法打开文件文件操作关闭文件使用模式打开文件以写入方式打开无法打开文件文件操作关闭文件使用模式打开文件以追加方式打开无法打开文件文件操作关闭文件首先使用函数以只读方式打开文件然后进行一些文件操作最后使用函数关闭文件接下来我们使用函数以写入方式打开文件进行一些文件操作然后使用函数关闭文件最后我们使用函数以追加方式打开文件进行一些文件操作然后使用函数关闭文件文件字符读写函数调用方式从指向的文件读入一个字符返回值读成功带回所读的字符失败则返回文件结束标志即函数调用方式把字符写到文件指针变量所指向的文件中返回值输出成功返回值就是输出的字符输出失败则返回即使用和函数进行示例打开输入文件无法打开输入文件打开输出文件无法打开输出文件从输入文件读取字符然后写入输出文件关闭文件首先使用函数以只读方式打开输入文件然后使用函数以写入方式打开输出文件接下来我们使用函数从输入文件中读取一个字符并将其作为类型的返回值存储在变量中然后我们使用函数将字符写入输出文件通过循环重复以上步骤直到到达输入文件的末尾最后我们使用函数关闭输入文件和输出文件文件字符串读写函数调用形式功能从指向的文件读入一个长度为的字符串存放带字符数组中中返回值读成功返回地址失败则返回函数调用形式功能把所指向的字符串写到文件指针变量所指向的文件中返回值输出成功返回否则返回非值函数写入文件无法打开文件函数读取文件无法打开文件你好世界成功写入文件读取到的文件内容定义了两个函数用于将字符串写入文件用于从文件中读取内容并打印出来在函数中我们使用函数将内容写入文件在函数中我们使用函数逐行读取文件内容并将每行内容打印出来在函数中我们首先调用将字符串你好世界写入名为的文件中然后调用从文件中读取内容并打印出来格式化方式读写文本文件在语言中是可以对文件进行格式化输入输出的即用到函数和函数作用和类似但读写的对象是文件而不是终端调用方式文件指针格式符字符串输出表列文件指针格式字符串输入表列举例将型变量和型变量的值按和的格式输出到指向的文件中从指向的文件中读取数据并将其存储在变量和中二进制文件数据块读写在程序中不仅需要一次输入输出一个数据而且常常需要一次输入输出一组数据如数组或结构体变量的值即用到函数和函数在读写时是以二进制形式进行的在向磁盘写数据时直接将内存中一组数据原封不动不加转换地复制到磁盘文件上在读入时也是将磁盘文件中若干字节的内容一批读入内存调用形式是一个地址对来说它是用来存放从文件读入的数据的存储区的地址对来说它是要把此地址开始的存储区中的数据向文件输出要读写的字节数要读写多少个数据项每个数据项长度为类型指针示例打开文件以进行读取无法打开文件从文件中读取数据到缓冲区成功读取个字符读取的内容是读取失败关闭文件打开文件以进行写入无法打开文件将缓冲区中的数据写入文件成功写入个字符写入失败关闭文件首先使用函数从一个名为的文件中读取最多个字符到缓冲区中然后使用函数将缓冲区中的数据写入一个名为的文件中最后打印出成功读取和写入的字符数随机读写数据文件不同于文件进行顺序读写随机访问读写不是按数据在文件中的物理位置次序进行读写而是可以对任何位置上的数据进行访问文件位置标记及其定位文件位置标记件位置标记是指在文件中标记当前读写位置的指针它用于记录文件中当前操作的位置在文件中的偏移量以便随时定位到文件的特定位置文件位置标记通常由文件指针表示文件指针是一个指向结构体的指针在打开文件时文件指针会被初始化为文件的起始位置随着读写操作的进行文件指针会自动更新通过文件位置标记我们可以在文件中进行随机访问读写不需要按照数据在文件中的物理位置次序进行操作可以根据需要将文件指针定位到任何位置然后进行读写操作文件位置标记的定位用函数使文件位置标记指向文件开头函数的作用是使文件位置标记重新返回文件的开头次函数没有返回值无法打开文件读取文件内容重置前重置文件位置标记到文件起始位置重新读取文件内容重置后关闭文件这个示例打开一个名为的文件并从文件中读取一行内容然后使用函数将文件位置标记重置为文件的起始位置再次读取文件内容并打印出来这样就可以看到在重新读取文件内容之前文件位置标记已经回到了文件的起始位置用函数改变文件位置标记函数用于将文件指针定位到特定位置调用形式指向要操作的文件的指针偏移量可以是正数负数或零正数表示向文件末尾方向移动负数表示向文件起始位置方向移动零表示不移动起始位置可以是以下值之一从文件起始位置开始计算偏移量从当前位置开始计算偏移量从文件末尾位置开始计算偏移量函数的返回值为表示成功非零值表示失败函数的作用是根据指定的偏移量和起始位置将文件指针定位到特定位置偏移量可以是正数负数或零用于指定相对于起始位置的移动距离起始位置可以是从文件起始位置开始计算偏移量从当前位置开始计算偏移量或从文件末尾位置开始计算偏移量使用函数可以实现以下功能将文件指针移动到文件的起始位置当前位置或末尾位置在文件中定位到特定位置进行读写操作跳过指定数量的字节或记录需要注意的是函数在定位文件指针时可能会受到一些限制例如如果文件是以文本模式而不是二进制模式打开的则函数可能无法准确地定位到指定的位置此外对于某些类型的文件如终端设备函数可能无法正常工作在使用函数之前需要确保文件已经成功打开并且需要检查函数的返回值以确定是否定位成功如果函数返回非零值则表示定位失败可能是由于文件指针超出了文件的范围或其他原因导致的随机读写有了和函数就可以实现随机读写的操作了无法打开文件使用将文件指针定位到文件末尾获取文件大小文件大小字节使用将文件指针定位到文件起始位置读取文件内容重置前使用将文件指针重置到文件起始位置重新读取文件内容重置后关闭文件首先使用函数将文件指针定位到文件末尾然后使用函数获取文件的大小并将其打印出来接下来我们使用函数将文件指针定位到文件起始位置然后使用函数读取文件的第一行内容并打印出来最后我们使用函数将文件指针重置到文件起始位置再次使用函数读取文件的第一行内容并打印出来',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-05-27 15:41:27',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.1.1"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="http://cdn.xykcola.site/blogPics/element/1712495829972.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" href="https://blog.xykcola.site/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xykcola.site/blogPics/element/1712495829972.jpg" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="http://user.xykcola.site/" title="用户中心"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xykcola.site/userPics/ele/logo.png" alt="用户中心"/><span class="back-menu-item-text">用户中心</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">这不是Cola</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a><div id="he-plugin-simple"></div><script>var WIDGET = {
  "CONFIG": {
    "modules": "0124",
    "background": "2",
    "tmpColor": "FFFFFF",
    "tmpSize": "16",
    "cityColor": "FFFFFF",
    "citySize": "16",
    "aqiColor": "E8D87B",
    "aqiSize": "16",
    "weatherIconSize": "24",
    "alertIconSize": "18",
    "padding": "10px 10px 10px 10px",
    "shadow": "0",
    "language": "auto",
    "borderRadius": "20",
    "fixed": "true",
    "vertical": "top",
    "horizontal": "left",
    "left": "20",
    "top": "7.1",
    "key": "df245676fb434a0691ead1c63341cd94"
  }
}
</script><link rel="stylesheet" href="https://widget.qweather.net/simple/static/css/he-simple.css?v=1.4.0"/><script src="https://widget.qweather.net/simple/static/js/he-simple.js?v=1.4.0"></script></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=320403036&amp;server=netease"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button only-home" id="travellings_button" title="随机前往一个开往项目网站"><a class="site-page" onclick="anzhiyu.totraveling()" title="随机前往一个开往项目网站" href="javascript:void(0);" rel="external nofollow" data-pjax-state="external"><i class="anzhiyufont anzhiyu-icon-train"></i></a></div><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://cdn.xykcola.site/blogPics/element/common/qrcode-wechat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src="https://cdn.xykcola.site/blogPics/element/common/qrcode-wechat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.xykcola.site/blogPics/element/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="https://cdn.xykcola.site/blogPics/element/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/C%E8%AF%AD%E8%A8%80/" style="font-size: 1.05rem;">C语言<sup>1</sup></a><a href="/tags/Java/" style="font-size: 1.05rem;">Java<sup>1</sup></a><a href="/tags/%E7%94%9F%E6%B4%BB/" style="font-size: 1.05rem;">生活<sup>1</sup></a><a href="/tags/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/" style="font-size: 1.05rem;">项目开发<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/06/"><span class="card-archive-list-date">六月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/04/"><span class="card-archive-list-date">四月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/03/"><span class="card-archive-list-date">三月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/" itemprop="url">后端开发</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/C%E8%AF%AD%E8%A8%80/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>C语言</span></a></span></div></div><h1 class="post-title" itemprop="name headline">C 语言笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2024-03-31T09:25:00.000Z" title="发表于 2024-03-31 17:25:00">2024-03-31</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2024-05-27T07:41:27.367Z" title="更新于 2024-05-27 15:41:27">2024-05-27</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">41.1k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>141分钟</span></span><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="C 语言笔记"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为吉林"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>吉林</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://cdn.xykcola.site/blogPics/post/202405/202405271431216.jpg"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://blog.xykcola.site/2024/03/31/C%20%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/"><header><a class="post-meta-categories" href="/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/" itemprop="url">后端开发</a><a href="/tags/C%E8%AF%AD%E8%A8%80/" tabindex="-1" itemprop="url">C语言</a><h1 id="CrawlerTitle" itemprop="name headline">C 语言笔记</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">这不是Cola</span><time itemprop="dateCreated datePublished" datetime="2024-03-31T09:25:00.000Z" title="发表于 2024-03-31 17:25:00">2024-03-31</time><time itemprop="dateCreated datePublished" datetime="2024-05-27T07:41:27.367Z" title="更新于 2024-05-27 15:41:27">2024-05-27</time></header><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>此笔记是本人根据<strong>谭浩强的教材《C程序设计（第五版）》</strong>及其结合<strong>自己在网上找的</strong>再自己写的。认真看完它并加上充分的练习应对期末、专升本应该是足够了，当然你也可以作为巩固复习资料使用，对初学者也是有一定的作用。<strong>当然，本人也是初学水平所做的复习笔记，如有不足之处还请谅解指正内容多，请结合大纲使用</strong></p>
<h1 id="第1章-程序设计和C语言"><a href="#第1章-程序设计和C语言" class="headerlink" title="第1章 程序设计和C语言"></a>第1章 程序设计和C语言</h1><h2 id="C语言的发展及其特点"><a href="#C语言的发展及其特点" class="headerlink" title="C语言的发展及其特点"></a>C语言的发展及其特点</h2><ul>
<li><strong>C语言发展：</strong></li>
</ul>
<p>C语言是由贝尔实验室的Dennis Ritchie在20世纪70年代初开发的一种通用计算机编程语言。C语言的设计目标是提供一种高效、可移植的编程语言，用于系统级编程和应用程序开发。其发展可以分为以下几个阶段：</p>
<ol>
<li><strong>诞生和发展初期（1970年代）</strong>：C语言最初是为了开发UNIX操作系统而设计的。在这个阶段，C语言的设计和实现主要由Dennis Ritchie和Ken Thompson完成。他们通过C语言的简洁和灵活性，成功地将UNIX系统移植到不同的计算机平台上。</li>
<li><strong>标准化（1980年代）</strong>：随着C语言的流行和广泛应用，人们开始意识到需要一个标准化的C语言规范，以确保不同的编译器能够产生相同的结果。于是，美国国家标准学会（ANSI）和国际标准化组织（ISO）联合制定了C语言的标准规范，于1989年发布了C89标准。</li>
<li><strong>C语言的变体和扩展（1990年代）</strong>：在C语言的基础上，出现了一些变体和扩展，如C++、Objective-C等。C++是由Bjarne Stroustrup在1980年代初开发的，它在C语言的基础上增加了面向对象编程的特性。Objective-C是由Brad Cox在1980年代初开发的，它在C语言的基础上增加了面向对象编程和动态运行时特性。</li>
<li><strong>标准更新（2000年代至今）</strong>：C语言的标准规范在2000年和2011年分别进行了更新，分别发布了C99和C11标准。这些更新主要是为了提供更多的特性和功能，以适应计算机技术的发展和应用需求的变化。</li>
</ol>
<ul>
<li><strong>C语言特点：</strong></li>
</ul>
<ol>
<li>语言简洁、紧凑，使用灵活方便、灵活</li>
<li>运算符丰富</li>
<li>数据类型丰富</li>
<li>具有结构化的控制语句。eg：if…else语句、while语句、do…while语句等</li>
<li>允许直接访问物理地址，能进行位（bit）操作，能实现编汇语言的大部分功能，可以直接对硬件进行操作</li>
</ol>
<p>C语言的程序的基本程序结构</p>
<ol>
<li><strong>一个程序由一个或多个源程序文件组成</strong></li>
</ol>
<ul>
<li><strong>预处理指令</strong></li>
</ul>
<p>预处理指令是在编译之前对源代码进行处理的指令，由以”#”开头的特殊语句组成。预处理指令不是真正的C语句，而是用来指导编译器在编译之前进行一些处理操作的。eg：#include：用于引入头文件，将头文件的内容插入到当前位置。#define：用于定义宏，将标识符替换为指定的值或代码片段</p>
<ul>
<li><strong>全局声明</strong></li>
</ul>
<p>全局声明是指在函数外部声明的变量或函数，其作用域在整个程序中都可见。全局声明可以在任何函数中使用，而不需要在每个函数中重新声明。eg：把“ int a，sum; ” 放到了main函数之前</p>
<ul>
<li><strong>函数定义</strong></li>
</ul>
<p>函数定义是指在程序中实现函数的具体功能。函数定义包括函数的返回类型、函数名、参数列表和函数体。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">返回类型 函数名(参数列表) &#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">    <span class="comment">// 执行具体的功能</span></span><br><span class="line">    <span class="comment">// 可能包含一条或多条语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<strong>返回类型指定函数的返回值类型，函数名是函数的标识符，参数列表是函数接受的输入参数，函数体是函数的具体实现</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> sum = a + b;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述函数定义中，返回类型是int，函数名是add，参数列表是(int a, int b)，函数体中计算了a和b的和，并将结果存储在sum变量中，最后通过return语句返回了sum的值。函数定义可以在程序中的任何位置，通常放在main函数之前。函数定义的目的是将函数的实现与函数的声明分离，使代码更加模块化和可维护。需要注意的是，<strong>函数定义必须与函数声明一致，即函数的返回类型、函数名和参数列表必须与函数声明中的一致</strong>。否则会导致编译错误。</p>
<ol>
<li><strong>函数是C程序的主要组成部分</strong>函数是C程序的主要组成部分，它们是用来执行特定任务的代码块。通过将代码分解为多个函数，可以使程序更加模块化和可维护。每个函数都有特定的功能，可以独立地编写、测试和调试。程序的执行从main函数开始，可以在main函数中调用其他函数来完成不同的任务。函数可以接受输入参数并返回一个值，用于传递数据和获取函数的结果。通过使用函数，可以提高程序的可读性、可重用性和可扩展性。</li>
<li><strong>一个函数包括两部分</strong></li>
</ol>
<ul>
<li><strong>函数首部</strong></li>
</ul>
<p>函数首部是指函数的声明或定义中的第一行，用于指定函数的返回类型、函数名和参数列表。函数首部的一般形式如下：<br>返回类型 函数名(参数列表);<br>其中：</p>
<ul>
<li>返回类型指定函数返回的数据类型，可以是基本类型（如int、float等）或者自定义的结构体类型。</li>
<li>函数名是函数的标识符，用于在程序中调用该函数。</li>
<li>参数列表指定函数接受的参数类型和参数名，多个参数之间用逗号分隔。</li>
</ul>
<p>举例：<br>int max(int num1, int num2);<br>这个函数首部声明了一个名为max的函数，返回类型为int，接受两个int类型的参数num1和num2。<br>float average(float arr[], int size);<br>这个函数首部声明了一个名为average的函数，返回类型为float，接受一个float类型的数组arr和一个int类型的size参数。<br>void printHello();<br>这个函数首部声明了一个名为printHello的函数，返回类型为void（即无返回值），不接受任何参数。</p>
<ul>
<li><strong>函数体</strong></li>
</ul>
<p>函数体是函数定义或声明中的代码块，用于实现函数的具体功能。函数体的一般形式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">返回类型 函数名(参数列表) &#123;</span><br><span class="line">    <span class="comment">// 函数体代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li>返回类型与函数首部中的返回类型相对应，指定函数返回的数据类型。</li>
<li>函数名与函数首部中的函数名相对应，用于在程序中调用该函数。</li>
<li>参数列表与函数首部中的参数列表相对应，指定函数接受的参数类型和参数名。</li>
</ul>
<p>举例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">square</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="type">int</span> result = num * num;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数体实现了一个名为square的函数，接受一个int类型的参数num，计算num的平方并返回结果。在函数体中，先定义一个局部变量result，将num乘以num的结果赋值给result，然后使用return语句将result作为函数的返回值返回。</p>
<ol>
<li><strong>程序总是从main函数开始执行</strong></li>
<li><strong>程序中要求计算机的操作是由函数中的C语句完成的</strong></li>
<li><strong>在每个数据声明和语句的最后必须要有一个分号</strong></li>
</ol>
<p>下面是一个满足上述要求的完整C语言代码示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">printHello</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="type">int</span> result = max(a, b);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;最大值是：%d\n&quot;</span>, result);</span><br><span class="line">    </span><br><span class="line">    printHello();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (num1 &gt; num2) &#123;</span><br><span class="line">        <span class="keyword">return</span> num1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printHello</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;你好，世界！\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，程序由一个源文件组成。首先，使用预处理指令#include &lt;stdio.h&gt;引入标准库头文件stdio.h，这样我们就可以使用printf和scanf等标准库函数。然后，在全局声明部分，我们声明了两个函数max和printHello，它们的函数原型分别出现在main函数之前，用于告诉编译器这两个函数的返回类型、函数名和参数列表。接下来，我们定义了主函数main，它是程序的入口点。在main函数中，我们声明了两个整型变量a和b，然后调用了函数max来求出a和b的最大值，并将结果存储在result变量中。最后，我们使用printf函数打印出最大值和一个简单的问候语。在max函数和printHello函数的定义中，我们分别实现了这两个函数的功能。max函数接受两个整型参数，并通过比较来确定最大值，并使用return语句返回该值。printHello函数不接受参数，直接打印出一个问候语。最后，我们在main函数最后返回了0，表示程序正常结束。请注意，每个语句和声明末尾都有一个分号，这是C语言中的语法规则。这些分号用于表示语句的结束。</p>
<hr>
<h2 id="结构化程序设计方法的思想"><a href="#结构化程序设计方法的思想" class="headerlink" title="结构化程序设计方法的思想"></a>结构化程序设计方法的思想</h2><ol>
<li>模块化：将程序分解为多个模块或函数，每个模块或函数负责处理特定的功能或任务。模块化的设计使得程序结构清晰，易于理解和维护。</li>
<li>自顶向下设计：从整体到局部的设计思路，先设计整体的程序结构和主要功能，然后逐步细化为更小的模块或函数。这种设计方法使得程序的层次结构清晰，易于理解和开发。</li>
<li>顺序、选择和循环结构：使用顺序、选择和循环结构来组织程序的逻辑流程。顺序结构按照代码的顺序执行，选择结构根据条件选择不同的执行路径，循环结构重复执行一段代码。</li>
<li>数据抽象和封装：将数据和对数据的操作封装在模块或函数中，只暴露必要的接口给外部使用。这种封装和抽象的方式提高了程序的可读性、可维护性和可重用性。</li>
<li>模块间的通信：模块之间通过参数传递和返回值来进行数据的交换和通信。模块之间的通信应该尽量简洁明了，避免过多的全局变量和副作用。</li>
</ol>
<h2 id="编辑、编译、运行一个C程序的步骤"><a href="#编辑、编译、运行一个C程序的步骤" class="headerlink" title="编辑、编译、运行一个C程序的步骤"></a>编辑、编译、运行一个C程序的步骤</h2><ol>
<li><strong>上机输入和编辑源程序</strong>C语言文件后缀（.c）</li>
<li><strong>对源程序进行编译预处理阶段</strong>是在编译之前进行的，主要处理以”#”开头的预处理指令，如包含头文件、宏定义等。预处理器会根据这些指令对源代码进行处理，生成一个经过宏展开、条件编译等处理的新的源代码文件。<strong>编译阶段</strong>将预处理后的源代码转换为汇编代码。编译器会对源代码进行词法分析、语法分析和语义分析，生成对应的中间代码（通常是汇编代码）。<strong>汇编阶段</strong>将汇编代码转换为机器代码。汇编器会将汇编代码翻译成机器指令，生成<strong>目标文件（通常是以”.o”或”.obj”为扩展名）。</strong></li>
<li><strong>进行链接处理链接阶段</strong>将目标文件与其他的目标文件或库文件进行合并，生成最终的可执行文件。链接器会解析目标文件中的符号引用，将其与其他目标文件或库文件中的符号定义进行匹配，生成最终的<strong>可执行文件（.exe）</strong>。</li>
<li><strong>运行可执行文件，得到运行结果</strong></li>
</ol>
<hr>
<h1 id="第2章-算法——程序的灵魂"><a href="#第2章-算法——程序的灵魂" class="headerlink" title="第2章 算法——程序的灵魂"></a>第2章 算法——程序的灵魂</h1><h2 id="算法的概念"><a href="#算法的概念" class="headerlink" title="算法的概念"></a>算法的概念</h2><p>一个程序包括两个方面：<strong>算法 + 数据结构 &#x3D; 程序</strong></p>
<ol>
<li><strong>对数据的描述</strong>在程序中要指定用到哪些数据，以及这些数据的类型和数据的组成形式，这就是数据结构</li>
<li><strong>对操作的描述</strong>要求计算机操作的步骤，也就是算法。</li>
</ol>
<h2 id="算法的特点"><a href="#算法的特点" class="headerlink" title="算法的特点"></a>算法的特点</h2><ol>
<li><strong>有穷性</strong>一个算法应该包括有限的操作步骤。</li>
<li><strong>确定性</strong>算法中的每一个步骤都应该是确定的。</li>
<li><strong>有零个或多个输入</strong>输入是指在执行算法时需要从外界取得必要的信息</li>
<li><strong>有一个或多个输出</strong>算法的目的是为了求解，解就是输出</li>
<li><strong>有效性</strong>算法中的每个步骤都应当能有效地进行，并得到确定的结果</li>
</ol>
<hr>
<h2 id="怎样表示一个算法"><a href="#怎样表示一个算法" class="headerlink" title="怎样表示一个算法"></a>怎样表示一个算法</h2><ol>
<li><strong>用自然语言（就是讲人话解释清楚）</strong></li>
<li><strong>用流程图算法表示</strong></li>
</ol>
<ul>
<li><strong>传统流程图</strong>传统流程图是一种图形化的工具，用于描述算法或程序的执行流程。它由各种不同形状的框和箭头组成，表示程序中的不同步骤和控制流程。<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xykcola.site/blogPics/post/202405/202405271426272.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xykcola.site/blogPics/post/202405/202405271426886.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xykcola.site/blogPics/post/202405/202405271426278.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xykcola.site/blogPics/post/202405/202405271426533.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xykcola.site/blogPics/post/202405/202405271427164.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xykcola.site/blogPics/post/202405/202405271427965.png"></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xykcola.site/blogPics/post/202405/202405271427618.png"></p>
<ul>
<li><strong>N-S流程图</strong>N-S流程图是一种简单的图表，用来描述一个过程或流程中的各个步骤和决策。它使用箭头表示流程的方向，起点为N（Start），终点为S（Stop）。在流程图中，不同的步骤和决策用不同的图形和符号表示。通过这种图表，人们可以清晰地了解和描述一个过程中的执行顺序和条件判断。<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xykcola.site/blogPics/post/202405/202405271427341.png"></li>
</ul>
<p>举例：输入三角形三边长，判断三遍构成的是等边，等腰，还是一般三角形</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xykcola.site/blogPics/post/202405/202405271427673.png"></p>
<ol>
<li><p><strong>用伪代码表示算法</strong>伪代码是一种类似于编程语言的描述性语言，用于描述算法或程序的逻辑结构和执行流程。它不是一种具体的编程语言，而是一种方便程序员理解和描述算法的工具。伪代码通常使用类似于编程语言的语法和关键字，但不需要遵循具体语言的语法规则。示例：计算两个数的和</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 输入两个数</span><br><span class="line">2. 计算和 = 第一个数 + 第二个数</span><br><span class="line">3. 显示和</span><br><span class="line">4. 结束</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>用计算机语言</strong>比如：用C语言、Java表示…</p>
</li>
</ol>
<h2 id="能够利用传统流程图和N-S流程图描述算法"><a href="#能够利用传统流程图和N-S流程图描述算法" class="headerlink" title="能够利用传统流程图和N-S流程图描述算法"></a>能够利用传统流程图和N-S流程图描述算法</h2><p>上面以及写过了，不用我在解释了吧 <strong>关键在多练</strong>，多做题你就会了</p>
<hr>
<h1 id="第3章-最简单的C程序设计—顺序程序设计"><a href="#第3章-最简单的C程序设计—顺序程序设计" class="headerlink" title="第3章 最简单的C程序设计—顺序程序设计"></a>第3章 最简单的C程序设计—顺序程序设计</h1><h2 id="常量和变量"><a href="#常量和变量" class="headerlink" title="常量和变量"></a>常量和变量</h2><p><strong>一、常量：在程序运行的过程中，其值不能被改变的量称为常量</strong></p>
<ol>
<li><strong>整型常量</strong>eg：1000、0、123.25、-652…</li>
<li><strong>实型常量</strong></li>
</ol>
<ul>
<li><strong>十进制小数形式。</strong>有数字和小数组成。eg：12.5….</li>
<li><strong>指数形式。</strong></li>
</ul>
<ol>
<li><strong>字符常量</strong></li>
</ol>
<ul>
<li><strong>普通字符。用单引号括起来的单个字符。</strong> eg：’5’、’e’、’?’….</li>
</ul>
<p>在C语言中，普通字符（char）在计算机中的存储通常使用ASCII编码。ASCII编码使用一个字节（8位）来表示一个字符，范围从0到127。其中，0到31是控制字符，32到126是可打印字符，而127是删除字符。例如，字符 ‘A’ 的ASCII码是65，以二进制表示为01000001。在计算机中，该字符会被存储为一个字节，即8位，从高位到低位依次为 0 1 0 0 0 0 0 1。<br><strong>ASCII表</strong><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xykcola.site/blogPics/post/202405/202405271427135.png"></p>
<ul>
<li><strong>转义字符。以 \ 开头的字符。</strong></li>
</ul>
<p>在C语言中使用字符串时，有时候需要插入一些特殊字符或者控制字符，这时就可以使用转义字符来实现。转义字符以反斜杠（\）开头，后面跟着一个或多个字符，用来表示特定的含义。例如，\n代表换行符，当我们在字符串中插入\n时，编译器会将其解释为换行符，输出时会在该位置换行。同样地，\t代表制表符，\r代表回车符，\b代表退格符，\f代表换页符等等。<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xykcola.site/blogPics/post/202405/202405271427451.png"></p>
<ol>
<li><strong>字符串常量。</strong>双引号括起来的若干个字符。eg：”hello”、”123”</li>
<li><strong>符号常量。</strong>用 #define 指令，指定用一个符号名称代表一个常量。</li>
</ol>
<p>#define PI 3.1415   &#x2F;&#x2F;末尾没有分号，程序用到 PI 就代表是3.1415</p>
<hr>
<p><strong>二、变量：在程序运行期间，其值可以改变的量叫做变量。变量在使用前需要先声明，声明变量时需要指定变量的类型和名称。</strong>在C语言中，变量的声明和使用有一些不同的语法。下面是一个使用变量的C语言例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 声明一个整数类型的变量</span></span><br><span class="line">    <span class="type">int</span> age = <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个字符类型的变量</span></span><br><span class="line">    <span class="type">char</span> grade = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个浮点数类型的变量</span></span><br><span class="line">    <span class="type">float</span> height = <span class="number">1.75</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改变量的值</span></span><br><span class="line">    age = <span class="number">26</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出变量的值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Age: %d\n&quot;</span>, age);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Grade: %c\n&quot;</span>, grade);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Height: %.2f\n&quot;</span>, height);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>在上面的例子中，我们首先包含了头文件<strong><strong>stdio.h</strong></strong>，该头文件中包含了输入输出函数的声明。然后，在<strong><strong>main</strong></strong>函数中声明了三个变量：<strong><strong>age</strong></strong>、<strong><strong>grade</strong></strong>和<strong><strong>height</strong></strong>，并给它们赋予了初始值。接着，我们修改了<strong><strong>age</strong></strong>变量的值，并使用<strong><strong>printf</strong></strong>函数输出了变量的值。在C语言中，变量的类型需要在声明时指定，并且变量名需要遵循一定的命名规则。不同的变量类型可以存储不同类型的数据。通过修改变量的值，我们可以改变变量存储的数据。需要注意的是，在C语言中，变量的声明通常放在函数的开头，而变量的使用可以放在任意位置。</strong></p>
<hr>
<p><strong>三、常变量</strong>（<strong>在定义变量前加一个 const ）表示该变量是常量，其值不能被修改。</strong>常变量一旦被初始化，其值将在整个程序执行过程中保持不变。<strong>举例：</strong><br>const int MAX_VALUE &#x3D; 100;<br>在上述例子中，MAX_VALUE被声明为一个常变量，其值为100，该值在程序执行期间不能被修改。</p>
<hr>
<h2 id="关键字和标识符"><a href="#关键字和标识符" class="headerlink" title="关键字和标识符"></a>关键字和标识符</h2><p><strong>一、标识符用来表示变量、函数、类、结构体等程序实体的名称叫做标识符。</strong>标识符的命名规则如下：</p>
<ul>
<li><strong>可以使用大小写字母（A-Z、a-z）、数字（0-9）和下划线（_）。</strong></li>
<li><strong>标识符开头必须是字符或者是下划线，不能以数字开头。</strong></li>
<li><strong>标识符区分大小写，例如”num”和”Num”是不同的标识符。</strong></li>
<li><strong>标识符不能是C语言的关键字，如if、for、int等。</strong></li>
</ul>
<p><strong>二、关键字</strong>关键字是在编程语言中具有特殊含义和用途的保留字。它们被编程语言用于表示语法结构、控制流程、定义数据类型等特定的功能和用途。关键字具有固定的语法和语义，不能作为标识符来使用。在C语言中，关键字用于表示条件判断、循环、函数返回值、数据类型等。例如，if关键字用于表示条件判断，for关键字用于表示循环，int关键字用于定义整型数据类型。举例：if、else、switch、while…..</p>
<hr>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>在C语言中，数据类型用于定义变量的类型，以及变量可以存储的数据范围和操作。<br><strong>一、整型数据</strong></p>
<ol>
<li><strong>基本整型（int 型）</strong></li>
</ol>
<p>占用4个字节，取值范围为-2,147,483,648到2,147,483,647或0到4,294,967,295</p>
<ol>
<li><strong>短整型 （short int型）</strong></li>
</ol>
<p>占用2个字节，取值范围为-32,768到32,767或0到65,535</p>
<ol>
<li><strong>长整型 （long int 型）</strong></li>
</ol>
<p>占用4个字节（32位系统）或8个字节（64位系统），取值范围为-2,147,483,648到2,147,483,647</p>
<ol>
<li><strong>双长整型 （long long int 型）</strong></li>
</ol>
<p>占用8个字节，取值范围为-9,223,372,036,854,775,808到9,223,372,036,854,775,807</p>
<ul>
<li><strong>在定义基本整型外，是可以像以下便捷操作的</strong><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> num01 = <span class="number">3</span>;</span><br><span class="line"><span class="type">long</span> num02 = <span class="number">4</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> num03 = <span class="number">5</span>;	<span class="comment">//int关键字可以省略</span></span><br></pre></td></tr></table></figure>
实际上等价于以下代码：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> <span class="type">int</span> num01 = <span class="number">3</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">int</span> num02 = <span class="number">4</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="type">int</span> num03 = <span class="number">5</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<p><strong>二、整型变量的符号属性C语言中的整型变量可以具有符号属性（有符号）或无符号属性（无符号），这取决于变量的声明方式。</strong>有符号整型变量可以表示正数、负数和零，而无符号整型变量只能表示非负数（包括零）。有符号整型变量的取值范围是从负最大值到正最大值之间，例如int类型的取值范围是-2,147,483,648到2,147,483,647。有符号整型变量的计算方式使用补码表示，即正数的二进制表示与无符号整型相同，而负数使用补码表示。无符号整型变量的取值范围是从0到正最大值之间，例如unsigned int类型的取值范围是0到4,294,967,295。无符号整型变量的计算方式直接使用二进制表示。在C语言中，整型变量的符号属性可以通过声明时的类型修饰符来指定。<br>例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> signedVar;           <span class="comment">// 有符号整型变量</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> unsignedVar; <span class="comment">// 无符号整型变量</span></span><br></pre></td></tr></table></figure>
<p><strong>如果不明确指定符号属性，默认情况下，int和unsigned int被视为有符号和无符号整型变量。unsigned short类型：</strong></p>
<ul>
<li>占用字节数：2字节，取值范围：0 到 65,535</li>
</ul>
<p><strong>unsigned int类型：</strong></p>
<ul>
<li>占用字节数：4字节，取值范围：0 到 4,294,967,295</li>
</ul>
<p><strong>unsigned long类型：</strong></p>
<ul>
<li>占用字节数：4字节（32位系统）或 8字节（64位系统），取值范围：0 到 4,294,967,295</li>
</ul>
<p><strong>unsigned long long类型：</strong></p>
<ul>
<li>占用字节数：8字节，取值范围：0 到 18,446,744,073,709,551,615</li>
</ul>
<hr>
<p><strong>三、字符型数据由于字符是按其代码（整数）形式储存的，因此在C语言中字符型数据作为整数类型的一种，但它又有自己的特点，需单独拿出来讲</strong></p>
<ol>
<li><strong>字符与字符代码</strong></li>
</ol>
<p>字符与字符代码并不是任写一个字符，程序都能识别。例如代表圆周率的 π 就是不能识别的，只能使用系统的字符集中的字符，目前大多数系统大多采用ASCII字符集。<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xykcola.site/blogPics/post/202405/202405271427389.png"></p>
<ol>
<li><strong>字符变量</strong></li>
</ol>
<p>字符变量就是用类型符** char **定义字符变量。char是英文character（字符）的缩写，见名知意。</p>
<ul>
<li><strong>有符号字符型（signed char，一般写作 char ）字节数：</strong></li>
</ul>
<p>通常为1个字节（8位），取值范围：-128 到 127。</p>
<ul>
<li><strong>无符号字符型（unsigned char）：</strong></li>
</ul>
<p>字节数：通常为1个字节（8位），取值范围：0 到 255。</p>
<hr>
<p><strong>四、浮点型数据</strong>用来表示具有小数点的实数</p>
<ul>
<li><strong>单精度浮点型（float 型）</strong><ul>
<li>通常占用4个字节（32位），其有效数字位数为约6-9位。该类型可以表示大约1.2e-38到3.4e+38之间的数值。</li>
</ul>
</li>
<li><strong>双精度浮点型（double 型）</strong><ul>
<li>通常占用8个字节（64位），其有效数字位数为约15-18位。该类型可以表示大约2.3e-308到1.7e+308之间的数值。</li>
</ul>
</li>
<li><strong>长双精度型 （long double 型）</strong><ul>
<li>占用的字节数较为可变，通常是8个字节或更多。其有效数字位数也会相应增加。这种类型通常提供比double更高的精度。</li>
</ul>
</li>
</ul>
<p>需要注意的是，数据类型的大小，取值范围和有效数字位数可能会因编译器和平台的不同而有所变化。</p>
<hr>
<h2 id="运算符与表达式"><a href="#运算符与表达式" class="headerlink" title="运算符与表达式"></a>运算符与表达式</h2><p>C语言提供了很多运算符，当前章节就讲讲算术运算符与赋值运算符<strong>一、基本算术运算符</strong></p>
<ul>
<li><p><strong>加法运算符（+）：将两个操作数相加。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> c = a + b;  <span class="comment">// c = 8</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>减法运算符（-）：从第一个操作数中减去第二个操作数。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> c = a - b;  <span class="comment">// c = 2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>乘法运算符（*）：将两个操作数相乘。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> c = a * b;  <span class="comment">// c = 15</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>除法运算符（&#x2F;）：将第一个操作数除以第二个操作数，得到商。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> c = a / b;  <span class="comment">// c = 3，因为是整型，所以结果没有小数点</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>取模运算符（%）：将第一个操作数除以第二个操作数，得到余数。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> c = a % b;  <span class="comment">// c = 1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>正号运算符（+）：表达数据为正</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+a;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>负号运算符（-）：表达数据位负</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-a;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<p><strong>二、自增自减运算符</strong></p>
<ol>
<li><strong>自增运算符有两种形式：前缀形式和后缀形式。</strong></li>
</ol>
<p>前缀形式的自增运算符（++x）<strong>会先将操作数的值增加1</strong>，然后返回增加后的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> y = ++x;  <span class="comment">// x = 6, y = 6</span></span><br></pre></td></tr></table></figure>
<p>后缀形式的自增运算符（x++）<strong>会先返回操作数的值</strong>，然后再将其增加1。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> y = x++;  <span class="comment">// x = 6, y = 5</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>自减运算符的使用方法与自增运算符类似，只是将值减少1。</strong></li>
</ol>
<p>前缀形式的自减运算符（–x）<strong>会先将操作数的值减少1</strong>，然后返回减少后的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> y = --x;  <span class="comment">// x = 4, y = 4</span></span><br></pre></td></tr></table></figure>
<p>后缀形式的自减运算符（x–）<strong>会先返回操作数的值，</strong>然后再将其减少1。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> y = x--;  <span class="comment">// x = 4, y = 5</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>三、算术表达式</strong>C语言的算术表达式是由操作数、运算符和括号组成的表达式，用于表示数值之间的运算关系。C语言支持一系列算术运算符，包括<strong>加法（+）、减法（-）、乘法（*）、除法（&#x2F;）和取模（%）</strong>等。算术表达式可以包含整数、浮点数和字符类型的操作数。这些操作数可以直接使用字面值，也可以是变量或表达式的结果。例如，下面是一些C语言的算术表达式的示例：</p>
<ol>
<li>** **整数运算：int a &#x3D; 5;int b &#x3D; 3;int c &#x3D; a + b; &#x2F;&#x2F; 加法运算，c的值为8int d &#x3D; a - b; &#x2F;&#x2F; 减法运算，d的值为2int e &#x3D; a * b; &#x2F;&#x2F; 乘法运算，e的值为15int f &#x3D; a &#x2F; b; &#x2F;&#x2F; 除法运算，f的值为1（整数除法）int g &#x3D; a % b; &#x2F;&#x2F; 取模运算，g的值为2</li>
<li>浮点数运算：float x &#x3D; 3.14;float y &#x3D; 2.0;float z &#x3D; x + y; &#x2F;&#x2F; 加法运算，z的值为5.14float w &#x3D; x * y; &#x2F;&#x2F; 乘法运算，w的值为6.28float q &#x3D; x &#x2F; y; &#x2F;&#x2F; 除法运算，q的值为1.57</li>
<li>混合类型运算：int m &#x3D; 5;float n &#x3D; 2.5;float p &#x3D; m + n; &#x2F;&#x2F; 加法运算，p的值为7.5float r &#x3D; m * n; &#x2F;&#x2F; 乘法运算，r的值为12.5float s &#x3D; m &#x2F; n; &#x2F;&#x2F; 除法运算，s的值为2.0</li>
</ol>
<p><em>*例如，表达式 a + b __ c 可以通过加上括号来明确指定运算的顺序：(a + b) *</em> c。<strong>同时也遵循先乘除后加减的优先级原则此外，C语言还支持一些其他的算术运算符和特殊的运算规则，如自增（++）、自减（–）、赋值运算符（&#x3D;）等。</strong></p>
<hr>
<p><strong>四、不同数据类型之间的混合运算</strong>在C语言中，不同类型之间的混合运算指的是在表达式中使用不同类型的操作数进行运算。当表达式中存在不同类型的操作数时，C语言会根据一组规则来确定运算的结果类型。</p>
<ol>
<li><p>**整数和浮点数的混合运算： **</p>
<ul>
<li>如果一个操作数是浮点数，那么另一个操作数将被自动转换为浮点数，结果将是浮点数。</li>
<li>如果一个操作数是整数，而另一个操作数是浮点数，那么整数将被自动转换为浮点数，结果将是浮点数。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">float</span> b = <span class="number">2.5</span>;</span><br><span class="line"><span class="type">double</span> c;</span><br><span class="line"></span><br><span class="line">c = a + b; <span class="comment">// 整数a被自动转换为浮点数，结果c为浮点数</span></span><br><span class="line">c = a * b; <span class="comment">// 整数a被自动转换为浮点数，结果c为浮点数</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>**字符和整数的混合运算： **</p>
<ul>
<li>字符可以被视为整数类型，因此可以与整数进行运算。</li>
<li>字符与整数之间的运算结果将是整数<strong>。</strong><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> ch = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="type">int</span> num = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> result;</span><br><span class="line"></span><br><span class="line">result = ch + num; <span class="comment">// 字符ch被视为整数类型，结果result为整数</span></span><br></pre></td></tr></table></figure>
ch是一个字符类型变量，其值为’A’，对应的ASCII码值为65。num是一个整数类型变量，其值为2。因此，最终结果是67</li>
</ul>
</li>
<li><p>**不同整数类型的混合运算： **</p>
<ul>
<li>如果两个操作数的类型不同，那么C语言会将它们转换为相同的类型，然后进行运算。</li>
<li>转换的规则是，将较小的整数类型转换为较大的整数类型。</li>
<li>long long &gt; long &gt; int &gt; short &gt; char<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> result;</span><br><span class="line"></span><br><span class="line">result = a + b; <span class="comment">// short类型的a被转换为int类型，结果result为int类型</span></span><br></pre></td></tr></table></figure>
<strong>需要注意的是，混合运算可能会导致数据丢失或精度损失。因此，在进行混合运算时，应该确保转换是安全和合理的，以避免出现错误。总之，在C语言中，不同类型之间的混合运算是允许的，并且根据一组规则来确定运算的结果类型。理解这些规则对于正确编写和理解表达式非常重要。</strong></li>
</ul>
</li>
</ol>
<hr>
<p><strong>五、强制类型转换运算符</strong>C语言中的强制类型转换运算符是一种用于显式地指定数据类型转换的运算符。它的语法形式是在要转换的值或表达式前面加上括号，并在括号内指定要转换的目标类型。例如：<br>(type) expression<br><strong>其中，<strong><strong>type</strong></strong>表示目标类型，<strong><strong>expression</strong></strong>表示要转换的值或表达式。</strong><br><strong>强制类型转换运算符可以用于以下几种情况：</strong></p>
<ol>
<li><p><strong>将一个表达式的结果强制转换为特定的类型。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">double</span> b = (<span class="type">double</span>) a;  <span class="comment">// 将整数a强制转换为浮点数类型double</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>将一个变量的类型强制转换为另一种类型。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">65</span>;</span><br><span class="line"><span class="type">char</span> ch = (<span class="type">char</span>) a;  <span class="comment">// 将整数a强制转换为字符类型char</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在混合运算中，显式地指定操作数的类型。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">double</span> b = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">int</span> c = (<span class="type">int</span>) (a + b);  <span class="comment">// 将表达式a + b的结果强制转换为整数类型int</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
</li>
</ol>
<ul>
<li><strong>强制类型转换只是转换当前的临时值，但该表达式结束后，数据仍为原类型。如第二个例子，在char ch &#x3D; (char) a; 过后，a 还是int整型。</strong></li>
<li><strong>需要注意的是，强制类型转换可能会导致数据的截断或溢出。因此，在进行强制类型转换时，应该确保转换是安全的，并且不会导致数据丢失或溢出。</strong></li>
<li><strong>此外，强制类型转换运算符的优先级较高，因此在表达式中使用时需要注意运算顺序。可以使用括号来明确指定运算顺序。</strong></li>
</ul>
<hr>
<p><strong>六、赋值语句</strong></p>
<ul>
<li><strong>赋值运算符（&#x3D;）：将一个数据赋值给一个变量</strong></li>
</ul>
<p>a &#x3D; 3;	&#x2F;&#x2F;把常量赋值给变量a</p>
<ul>
<li><strong>复合赋值运算符</strong></li>
</ul>
<p>C语言中的复合赋值运算符是一种简化表达式的方式，它将运算符和赋值操作结合在一起。下面是C语言中的所有复合赋值运算符及其解释：</p>
<ul>
<li><strong>+&#x3D;：加法赋值运算符</strong></li>
</ul>
<p>将右操作数的值加到左操作数上，并将结果赋给左操作数。例如，a +&#x3D; b等价于a &#x3D; a + b</p>
<ul>
<li><strong>-&#x3D;：减法赋值运算符</strong></li>
</ul>
<p>将右操作数的值从左操作数中减去，并将结果赋给左操作数。例如，a -&#x3D; b等价于a &#x3D; a - b</p>
<ul>
<li><strong>&#x3D;：乘法赋值运算符</strong></li>
</ul>
<p>将右操作数的值乘以左操作数，并将结果赋给左操作数。例如，a *&#x3D; b等价于a &#x3D; a * b</p>
<ul>
<li><strong>&#x2F;&#x3D;：除法赋值运算符</strong></li>
</ul>
<p>将左操作数的值除以右操作数，并将结果赋给左操作数。例如，a &#x2F;&#x3D; b等价于a &#x3D; a &#x2F; b</p>
<ul>
<li><strong>%&#x3D;：取模赋值运算符</strong></li>
</ul>
<p>将左操作数的值除以右操作数得到的余数，并将结果赋给左操作数。例如，a %&#x3D; b等价于a &#x3D; a % b</p>
<hr>
<h2 id="数据的输入输出"><a href="#数据的输入输出" class="headerlink" title="数据的输入输出"></a>数据的输入输出</h2><p><strong>一、用 printf函数输出数据</strong>printf函数（格式输出函数）用来向终端输出若干个任意类型的数据</p>
<ol>
<li><strong>printf函数的一般格式</strong><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(格式控制, 输出列表);</span><br><span class="line"><span class="comment">//举例</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="type">char</span> c = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d,%c\n&quot;</span>,i,c);</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><strong>“格式控制”：</strong>是用<strong>英文双引号</strong>括起来的一个字符串，称为格式控制字符串，简称格式字符串</li>
</ul>
<p>包含以下两个信息：</p>
<ul>
<li><strong>格式声明：</strong></li>
</ul>
<p>由<strong>“%”</strong>和 **格式字符 **组成，如%d、%f。将输出的数据转换为指定的格式后输出，总是有 **”%” **开始的</p>
<ul>
<li><strong>普通字符：</strong></li>
</ul>
<p>即需要输出时原样输出的字符。如双引号中的逗号、空格、换行符….</p>
<ul>
<li><strong>输出列表：</strong>是程序需要输出的一些数据，可以是常量、变量、或者表达式。如上例中的 <strong>“ i 和 c“</strong><br>2<strong>格式字符</strong></li>
</ul>
<p>在输出时，不同的数据类型需要指定不同的格式声明，格式声明中最重要的内容是格式字符。</p>
<ul>
<li><p><strong>d 、i 格式字符</strong>：用于输出有符号十进制整数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, num); <span class="comment">// 输出：10</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%i\n&quot;</span>, num); <span class="comment">// 输出：10</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>u 格式符：</strong>用于输出无符号十进制整数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> Num = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%u\n&quot;</span>, Num); <span class="comment">// 输出：20</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>f 格式符：</strong>用于输出浮点数</p>
<ul>
<li><strong>基本型，用%f</strong><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> fNum = <span class="number">3.14</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, fNum); <span class="comment">// 输出：3.140000</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>指定数据宽度和小数位数，用 %m.nf</strong></p>
</li>
</ul>
<p>m代表输出的数据占几位，n代表输出几位小数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> x = <span class="number">3.14159</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%8.2f\n&quot;</span>, x);</span><br></pre></td></tr></table></figure>
<p>输出：<br>3.14<br>%8.2f 中的8代表输出的数据占8位，其中包括小数点和小数位数。2代表输出2位小数。<br>因此，输出结果为3.14，小数点前面有4个空格，总共占了8位。</p>
<ul>
<li><strong>输出的数据向左对齐，用 %-m.nf</strong></li>
</ul>
<p>m代表输出的数据占几位，n代表输出几位小数，- 代表向左对齐</p>
<ul>
<li><p><strong>c 格式符：</strong>用于输出字符</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> ch = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, ch); <span class="comment">// 输出：A</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>s 格式符：</strong>用于输出字符串</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str); <span class="comment">// 输出：Hello, World!</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>p 格式符：</strong>用于输出指针地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = &amp;num;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, ptr); <span class="comment">// 输出：0x7ffeed56a9c4 （根据具体内存地址而定）</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>%x：用于输出十六进制整数（小写字母）</p>
</li>
<li><p>%X：用于输出十六进制整数（大写字母）</p>
</li>
<li><p>%o：用于输出八进制整数</p>
</li>
<li><p>%e：用于输出科学计数法表示的浮点数（小写字母）</p>
</li>
<li><p>%E：用于输出科学计数法表示的浮点数（大写字母）</p>
</li>
<li><p>%g：根据数值的大小自动选择使用%f或%e格式输出浮点数（小写字母）</p>
</li>
<li><p>%G：根据数值的大小自动选择使用%f或%E格式输出浮点数（大写字母）</p>
</li>
<li><p>%%：用于输出百分号</p>
</li>
</ul>
<p><strong>注意：</strong>在格式声明中，在 % 和上述格式字符键可以插入以下附加字符（又称修饰符）</p>
<ul>
<li><strong>l 长整型整数：</strong></li>
</ul>
<p>长整型整数是一种数据类型，用于存储比普通整数更大的整数值，可以加在格式符 d、o、x、u 前面，如 <strong>%ld、%lld</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">int</span> num1 = <span class="number">1234567890</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="type">int</span> num2 = <span class="number">1234567890123456789</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用%ld打印long int类型的整数</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Long int: %ld\n&quot;</span>, num1); <span class="comment">// 输出：1234567890</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用%lld打印long long int类型的整数</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Long long int: %lld\n&quot;</span>, num2); <span class="comment">// 输出：1234567890123456789</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>m.n 字符：</strong></li>
</ul>
<p><strong>m代表数据最小宽度；n实数表示输出n位小数，对字符串表示截取的字符个数（m、n都代表一个正整数）</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num1 = <span class="number">123</span>;</span><br><span class="line"><span class="type">float</span> num2 = <span class="number">3.14159</span>;</span><br><span class="line"><span class="type">char</span> ch = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用%5d打印整数，最小宽度为5</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Integer: %5d\n&quot;</span>, num1); <span class="comment">// 输出：  123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用%8.2f打印浮点数，最小宽度为8，小数位数为2</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Float: %8.2f\n&quot;</span>, num2); <span class="comment">// 输出：    3.14</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用%c打印字符</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Character: %c\n&quot;</span>, ch); <span class="comment">// 输出：A</span></span><br></pre></td></tr></table></figure>
<p>定义了一个整数 num1，一个浮点数 num2 和一个字符 ch使用不同的格式符来打印这些数据，同时指定了最小宽度和小数位数。使用%md来打印整数，其中m表示最小宽度。使用%m.nf来打印浮点数，其中m表示最小宽度，n表示小数位数。使用%c来打印字符。</p>
<p>输出的数字或字符在域内向左靠当我们使用-标志时，输出的数字或字符将在域内向左靠齐。<br>下面是一个使用-标志的C语言代码示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num1 = <span class="number">123</span>;</span><br><span class="line"><span class="type">float</span> num2 = <span class="number">3.14159</span>;</span><br><span class="line"><span class="type">char</span> ch = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用%-5d打印整数，最小宽度为5，左对齐</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Integer: %-5d\n&quot;</span>, num1); <span class="comment">// 输出：123  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用%-8.2f打印浮点数，最小宽度为8，小数位数为2，左对齐</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Float: %-8.2f\n&quot;</span>, num2); <span class="comment">// 输出：3.14    </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用%-c打印字符，左对齐</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Character: %-c\n&quot;</span>, ch); <span class="comment">// 输出：A</span></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们定义了一个整数num1，一个浮点数num2和一个字符ch。使用-标志与其他格式符一起使用，来使输出的数字或字符在域内向左靠齐。使用%-md来打印整数，其中m表示最小宽度。使用%-m.nf来打印浮点数，其中m表示最小宽度，n表示小数位数。使用%-c来打印字符。这些格式符与-标志一起使用，可以使输出的数字或字符在域内向左靠齐。</p>
<hr>
<p><strong>二、scanf函数输入数据</strong></p>
<ol>
<li><strong>一般形式</strong></li>
</ol>
<p>scanf(格式控制，地址列表);</p>
<ul>
<li><strong>格式控制：</strong></li>
</ul>
<p>含义同 printf 函数的格式控制</p>
<ul>
<li><strong>地址表列：</strong></li>
</ul>
<p>由若干个地址组成的表列，可以是变量的地址，或字符串的首地址。**&amp; 为取地址符，字如其意<strong>在 C 语言中，scanf 函数用于从用户输入中读取数据。它的工作方式是通过引用传递来修改变量的值。</strong>为了让 <strong><strong>scanf</strong></strong> 函数能够修改变量的值，我们需要向其提供变量的地址。这就是在 <strong><strong>scanf</strong></strong> 中使用 <strong><strong>&amp;</strong></strong> 的原因。****&amp;**** 运算符用于获取变量的地址。当我们在 <strong><strong>scanf</strong></strong> 中使用 <strong><strong>&amp;</strong></strong> 运算符时，它表示我们要将变量的地址传递给 <strong><strong>scanf</strong></strong> 函数，以便它可以直接修改变量的值。**<strong>示例：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num); <span class="comment">// 使用 &amp; 获取 num 的地址，并将用户输入的值存储在 num 中</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;用户输入的值：%d\n&quot;</span>, num);</span><br></pre></td></tr></table></figure>
<p><strong>在上面的示例中，**<strong>scanf</strong></strong> 函数使用 <strong><strong>%d</strong></strong> 格式说明符来读取用户输入的整数。为了让 <strong><strong>scanf</strong></strong> 函数能够修改 <strong><strong>num</strong></strong> 的值，我们使用 <strong><strong>&amp;</strong></strong> 运算符获取 <strong><strong>num</strong></strong> 的地址，并将其传递给 <strong><strong>scanf</strong></strong> 函数。<strong><strong>需要注意的是，</strong></strong>&amp;**** 运算符只能用于具有内存地址的变量。它不能用于常量、表达式或函数调用的结果。**</p>
<ol start="2">
<li><strong>格式声明</strong></li>
</ol>
<p>与printf函数中的格式声明相似，以 <strong>%</strong> 开始，以一个格式字符结束，中间也可以插入附加的字符。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;a = %d&quot;</span>,&amp;a);	<span class="comment">//&amp;为取地址符，字如其意</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>d 、i 格式符：</strong>输入有符号的十进制整数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>u 格式符：</strong>输入无符号的十进制</p>
</li>
<li><p><strong>o 格式符：</strong>输入无符号的八进制</p>
</li>
<li><p><strong>x 、X 格式符：</strong>输入无符号的十六进制整数（大小写作用相同）</p>
</li>
<li><p><strong>e 格式符：</strong>输入单个字符</p>
</li>
<li><p><strong>s 格式符：</strong></p>
</li>
</ul>
<p>输入字符串，将字符串送到一个字符数组中，在输入时以非空白字符开始，以第一个空白字符结束。字符串以标志 ‘<strong>\0</strong>‘ 作为其最后一个字符</p>
<ul>
<li><strong>f 格式符：</strong>输入实数，可以用小数形式或指数形式输入</li>
<li><strong>e 、E 、g 、G 格式符：</strong>与 f 作用相同，e 与 f 、g 可以互相替换（大小写作用相同）</li>
<li><strong>scanf 函数中用到的格式附加字符</strong><ul>
<li><strong>l 字符：</strong>输入长整型数据<strong>，</strong>如%ld、%lo、%lx、%lu 以及 double型数据类型%lf、%le</li>
<li><strong>h 字符：</strong>输入短整型数据，如%hd、%ho、%hx</li>
<li>*** 字符：**本输入项在输入后不赋给相应的变量</li>
<li><strong>m 字符：</strong></li>
</ul>
</li>
</ul>
<p><strong>m代表输入数据所占宽度（m代表一个正整数）</strong></p>
<hr>
<p><strong>三、字符输入输出函数</strong></p>
<ol>
<li><strong>putchar 函数输出一个字符</strong></li>
</ol>
<p>只要是字符都可以。字符类型也属于整数类型，对照ASCII表，putchar(65); 与 putchar(A); 都输出字符 B</p>
<ul>
<li><strong>一般形式</strong></li>
</ul>
<p>putchar(c);	&#x2F;&#x2F; c为一个字符</p>
<ol start="2">
<li><strong>getchar 函数输入一个字符</strong></li>
</ol>
<ul>
<li><strong>一般形式</strong><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a;</span><br><span class="line">a = getchar();	<span class="comment">// 从键盘输入一个字符，传给字符变量a</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h1 id="第4章-选择结构程序设计"><a href="#第4章-选择结构程序设计" class="headerlink" title="第4章 选择结构程序设计"></a>第4章 选择结构程序设计</h1><h2 id="关系、逻辑运算符"><a href="#关系、逻辑运算符" class="headerlink" title="关系、逻辑运算符"></a>关系、逻辑运算符</h2><ol>
<li><strong>关系运算符</strong></li>
</ol>
<p>在C语言中，关系运算符用于比较两个值之间的关系，结果为真（非零）或假（零）。逻辑运算符用于组合多个关系表达式，结果为真或假。C语言中常用的关系运算符：</p>
<ul>
<li><strong>相等：&#x3D;&#x3D;</strong></li>
<li><strong>不等：!&#x3D;</strong></li>
<li><strong>大于：&gt;</strong></li>
<li><strong>小于：&lt;</strong></li>
<li><strong>大于等于：&gt;&#x3D;</strong></li>
<li><strong>小于等于：&lt;&#x3D;</strong></li>
</ul>
<ol start="2">
<li><strong>逻辑运算符</strong></li>
</ol>
<p>逻辑运算符用于组合多个关系表达式，常用的逻辑运算符有：</p>
<ul>
<li><strong>逻辑与：&amp;&amp;</strong></li>
<li><strong>逻辑或：||</strong></li>
<li><strong>逻辑非：!</strong></li>
</ul>
<p>表达式是由操作数和运算符组成的。操作数可以是变量、常量或表达式的结果，运算符用于操作操作数。通过组合运算符和操作数，可以构建复杂的表达式来进行计算和判断。例如，下面的表达式计算两个数的平均值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> average;</span><br><span class="line"></span><br><span class="line">average = (a + b) / <span class="number">2</span>; <span class="comment">// 计算a和b的和，然后除以2，得到平均值</span></span><br></pre></td></tr></table></figure>
<p>在这个表达式中，(a + b)计算了 a 和 b 的和，然后除以2得到平均值，并将结果存储在变量 average 中。</p>
<hr>
<h2 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h2><p>在C语言中，<strong>条件运算符（也称为三元运算符）</strong>是一种简洁的条件表达式，用于根据条件的真假选择不同的值。条件运算符的语法如下：<br>expression1 ? expression2 : expression3<br>其中，expression1 是一个条件表达式，其结果可以是真（非零值）或假（零值）。如果条件表达式为真，则整个表达式的值为 expression2；如果条件表达式为假，则整个表达式的值为 expression3。<br>条件运算符的示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> max = (a &gt; b) ? a : b;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，如果 a 大于 b，则 max 被赋值为 a 的值；否则 max 被赋值为 b 的值。</p>
<hr>
<h2 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a><strong>if 语句</strong></h2><p>if语句是一种条件语句，用于在满足特定条件时执行一段代码。它的基本操作包括以下几个步骤：</p>
<ol>
<li><strong>检查条件：</strong>首先，<strong>if语句会检查指定的条件是否为真（非零）</strong>。条件可以是一个表达式，也可以是一个变量的值。如果条件为真，即满足条件，那么将执行if语句后面的代码块；如果条件为假（即为0），那么将跳过if语句的代码块，继续执行后面的代码。</li>
<li><strong>执行代码块：</strong>如果条件为真，那么将执行if语句后面的代码块。代码块是由一对花括号{}包围的一组语句组成，可以是单个语句或多个语句的集合。这些语句可以是任何合法的C语言语句，例如变量赋值、函数调用、条件语句、循环语句等。</li>
<li><strong>跳过代码块：</strong>如果条件为假，那么将跳过if语句后面的代码块，继续执行后面的代码。这意味着if语句的代码块只会在条件为真时执行，否则将被忽略。</li>
</ol>
<p>使用if语句的示例，用于判断一个数是否为正数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">if</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;这个数是正的\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，if语句检查num &gt; 0的条件是否为真。因为num的值为5，满足条件，所以将执行if语句后面的代码块，输出 “这个数是正的”。如果num的值为负数或零，那么条件为假，将跳过if语句的代码块，不会输出任何内容。</p>
<hr>
<p><strong>if 语句的三种形式</strong></p>
<ol>
<li><strong>if语句：</strong></li>
</ol>
<p>if 语句用于在条件为真时执行一段代码。语法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">     <span class="comment">// 当condition为真时执行的代码</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>例如，下面的代码根据变量num的值判断是否为正数，并输出相应的信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">5</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">if</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;这个数是正的\n&quot;</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>如果num的值大于0，则条件为真，将会执行printf语句输出 “The number is positive.”。</p>
<ol>
<li><strong>if-else语句：</strong></li>
</ol>
<p>if-else语句用于在条件为真时执行一个代码块，否则执行另一个代码块。语法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">     <span class="comment">// 当condition为真时执行的代码</span></span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">// 当condition为假时执行的代码</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>例如，下面的代码根据变量num的值判断是否为正数，并输出相应的信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">-3</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">if</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;这个数是正的\n&quot;</span>);</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;这个数不是正的\n&quot;</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>如果num的值大于0，则条件为真，将会执行第一个printf语句输出 “这个数是正的”。否则，将会执行第二个printf语句输出 “这个数不是正的”。</p>
<ol>
<li><strong>if-else if语句：</strong></li>
</ol>
<p>if-else if语句用于根据多个条件选择不同的代码块执行。语法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition1) &#123;</span><br><span class="line">     <span class="comment">// 当condition1为真时执行的代码</span></span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (condition2) &#123;</span><br><span class="line">     <span class="comment">// 当condition2为真时执行的代码</span></span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">// 当所有条件都为假时执行的代码</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>例如，下面的代码根据变量score的值判断学生的等级，并输出相应的信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> score = <span class="number">85</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">if</span> (score &gt;= <span class="number">90</span>) &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Grade A\n&quot;</span>);</span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">80</span>) &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Grade B\n&quot;</span>);</span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">70</span>) &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Grade C\n&quot;</span>);</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Grade D\n&quot;</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>根据score的值，将会执行相应的printf语句输出对应的等级。在这个例子中，score的值为85，满足第二个条件score &gt;&#x3D; 80，因此将会执行第二个printf语句输出 “Grade B”。</p>
<hr>
<h2 id="Switch-Break-语句"><a href="#Switch-Break-语句" class="headerlink" title="Switch Break 语句"></a>Switch Break 语句</h2><p>Switch语句是一种多分支选择结构，用于根据不同的条件执行不同的代码块。它的基本语法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (表达式) &#123;</span><br><span class="line">    <span class="keyword">case</span> 值<span class="number">1</span>:</span><br><span class="line">        <span class="comment">// 如果表达式匹配值1，则执行这里的代码</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 值<span class="number">2</span>:</span><br><span class="line">        <span class="comment">// 如果表达式匹配值2，则执行这里的代码</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 值<span class="number">3</span>:</span><br><span class="line">        <span class="comment">// 如果表达式匹配值3，则执行这里的代码</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// 如果表达式不匹配任何值，则执行这里的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>switch语句的执行过程如下：</p>
<ol>
<li>表达式求值：首先，计算表达式的值。表达式可以是一个变量或一个常量值。</li>
<li>匹配值：接下来，将计算得到的表达式的值与每个case语句后面的值进行比较，以确定是否匹配。</li>
<li>执行代码块：如果匹配成功，即表达式的值与某个case语句后面的值相等，那么将执行该case语句后面的代码块。代码块是由一对花括号{}包围的一组语句组成。</li>
<li>跳出switch语句：在执行完匹配的代码块后，程序会继续执行后面的代码。为了避免执行其他case语句后面的代码块，可以在每个case语句的末尾使用break语句来跳出switch语句。</li>
</ol>
<p>如果表达式的值与任何case语句后面的值都不匹配，那么将执行default语句后面的代码块（如果有）。default语句是可选的，用于处理表达式不匹配的情况。<br><strong>使用switch语句的示例，根据用户输入的数字输出相应的季节：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> month;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入一个月份：&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;month);</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (month) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;冬季\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;春季\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;夏季\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;秋季\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;输入的月份无效\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="第5章-循环结构程序设计"><a href="#第5章-循环结构程序设计" class="headerlink" title="第5章 循环结构程序设计"></a>第5章 循环结构程序设计</h1><h2 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h2><p><strong>while</strong> <strong>循环</strong>是一种常用的循环结构。它的作用是在满足指定条件的情况下，重复执行一段代码块。以下是while循环的基本语法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (条件) &#123;</span><br><span class="line">    <span class="comment">// 要执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在循环开始之前，首先会对条件进行评估。如果条件为真（非零值），循环体中的代码将会被执行。执行完循环体中的代码后，再次对条件进行评估。如果条件仍然为真，循环将会继续执行，直到条件为假（零值），此时循环结束，程序继续执行循环之后的代码。以下是一个使用while循环的示例程序，用于打印从1到10的数字：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个程序中，while (i &lt;&#x3D; 10)作为循环的条件。只要i的值小于等于10，循环体中的代码都会被执行。循环体中首先会打印当前的i的值，然后通过i++将i的值增加1，以准备下一次循环。程序会重复执行这个过程，直到i的值大于10，循环就会结束。以上程序的输出结果为：1 2 3 4 5 6 7 8 9 10。</p>
<hr>
<h2 id="do-while-循环"><a href="#do-while-循环" class="headerlink" title="do while 循环"></a>do while 循环</h2><p>C语言中的do-while语句是一种循环结构，用于重复执行一段代码块，直到满足指定的条件为止。它的基本语法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// 循环体代码</span></span><br><span class="line">&#125; <span class="keyword">while</span> (条件);</span><br></pre></td></tr></table></figure>
<p>do-while循环的执行过程是先执行一次循环体代码，然后再检查条件是否满足。如果条件为真，则继续执行循环体代码；如果条件为假，则退出循环。下面是一个使用do-while循环的示例程序，计算1到10的累加和：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        sum += num;</span><br><span class="line">        num++;</span><br><span class="line">    &#125; <span class="keyword">while</span> (num &lt;= <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1到10的累加和是：%d\n&quot;</span>, sum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个程序中，使用do-while循环计算了1到10的累加和。首先将num初始化为1，然后在循环体内将num添加到sum中，并递增num的值。当num的值小于等于10时，继续执行循环体代码。当num的值达到11时，不满足条件，退出循环。最后输出累加和的结果。</p>
<hr>
<h2 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h2><p>for语句是一种常用的循环结构，用于重复执行一个代码块，可以指定起始条件、循环条件和循环迭代。它的基本语法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (初始化语句; 循环条件; 迭代语句) &#123;</span><br><span class="line">    <span class="comment">// 循环体代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>for循环的执行过程是先执行初始化语句，然后检查循环条件是否满足。如果条件为真，则执行循环体代码，并执行迭代语句；如果条件为假，则退出循环。<br>下面是一个使用for循环的示例程序，计算1到10的累加和：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num = <span class="number">1</span>; num &lt;= <span class="number">10</span>; num++) &#123;</span><br><span class="line">        sum += num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1到10的累加和是：%d\n&quot;</span>, sum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个程序中，使用for循环计算了1到10的累加和。循环的初始化语句将num初始化为1，循环的条件是num小于等于10，循环的迭代语句是对num进行递增操作。在每次循环中，将num添加到sum中。当循环条件不满足时，即num大于10时，退出循环。最后输出累加和的结果。</p>
<hr>
<h2 id="break、continue作用"><a href="#break、continue作用" class="headerlink" title="break、continue作用"></a>break、continue作用</h2><p>break语句可用于<strong>switch语句的跳出</strong>和<strong>循环中断的跳出</strong></p>
<ul>
<li><strong>break 语句</strong></li>
</ul>
<p><strong>break语句</strong>用于中断当前所在的循环结构，即在满足某个条件时提前跳出循环，结束循环的执行。当break语句执行时，程序将跳出当前的循环，并执行循环后面的代码。下面是一个使用break语句的示例程序，其中使用了一个无限循环（while循环），并在满足某个条件时使用break语句跳出循环：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入一个整数（输入0结束循环）：&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;  <span class="comment">// 如果输入的整数是0，则跳出循环</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;你输入的整数是：%d\n&quot;</span>, num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;循环结束！\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>在这个程序中，使用了一个无限循环（while循环），并在循环内部输入一个整数。如果输入的整数是0，则使用break语句跳出循环。否则，输出输入的整数。当输入的整数为0时，循环将被提前结束，跳出循环，并执行后续的代码。</p>
<ul>
<li><strong>continue 语句</strong></li>
</ul>
<p><strong>continue语句</strong>用于终止当前循环迭代中的剩余语句，并进入下一次循环迭代。也就是说，当程序执行到continue语句时，会跳过当前循环迭代剩余的代码，然后继续下一次迭代。通过使用一个for循环，找出一个整数数组中的偶数，并输出这些偶数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"> <span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="type">int</span> numbers[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">         <span class="comment">// 如果是奇数，则跳过当前循环迭代，继续下一次迭代</span></span><br><span class="line">         <span class="keyword">if</span> (numbers[i] % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">             <span class="keyword">continue</span>;</span><br><span class="line">         &#125;</span><br><span class="line"> </span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, numbers[i]);</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，使用一个for循环迭代整数数组numbers。当遇到奇数时，使用continue语句跳过当前迭代，继续下一次迭代。只有当遇到偶数时，才会执行输出语句。因此，程序输出结果为：2 4 6 8 10</p>
<hr>
<h1 id="第6章-利用数组处理批量数据"><a href="#第6章-利用数组处理批量数据" class="headerlink" title="第6章 利用数组处理批量数据"></a>第6章 利用数组处理批量数据</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ol>
<li><strong>数组的定义</strong></li>
</ol>
<p>C语言中的数组，可用于存储一系列<strong>相同类型</strong>的元素。数组可以在内存中连续存储多个元素，并*<em>通过索引（或者叫下标）来访问和操作这些元素。数组的定义形式：</em>***数据类型 数组名[数组长度];**<strong>数据类型指定了数组中元素的类型，数组名是数组的标识符，数组长度指定了数组可以存储的元素个数。</strong>定义一个包含5个整数的数组：<br>int numbers[5];</p>
<hr>
<ol>
<li><strong>数组的初始化</strong></li>
</ol>
<p>数组的初始化可以在定义时进行，也可以在后续的代码中进行。</p>
<ul>
<li><strong>静态初始化：</strong> 在定义时就定义了所有数据</li>
</ul>
<p>int numbers[5] &#x3D; {1, 2, 3, 4, 5};</p>
<ul>
<li><strong>动态初始化：</strong> 先定义数组，再后续定义数据<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> numbers[<span class="number">5</span>];</span><br><span class="line">numbers[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">numbers[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">numbers[<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line">numbers[<span class="number">3</span>] = <span class="number">4</span>;</span><br><span class="line">numbers[<span class="number">4</span>] = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<strong>数组的长度是固定的，一旦定义后就不能改变。</strong> 如果需要存储更多的元素，可以重新定义一个更大长度的数组，并将原数组中的元素复制到新数组中。</li>
</ul>
<hr>
<ol>
<li><strong>数组的访问</strong></li>
</ol>
<p>在C语言中，可以使用<strong>索引（或者叫下标）</strong>来访问数组中的元素。数组的<strong>索引（或者叫下标）从0开始递增</strong>，表示数组中元素的位置。*<em>访问数组元素的方式为：</em>***数组名[索引]**<strong>。</strong><br>例如，对于一个包含5个整数的数组 numbers，可以使用索引0、1、2、3、4来表示数组中的第1个、第2个、第3个、第4个和第5个元素。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> numbers[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = numbers[<span class="number">0</span>];  <span class="comment">// 访问数组中的第1个元素，x的值为1</span></span><br><span class="line"><span class="type">int</span> y = numbers[<span class="number">2</span>];  <span class="comment">// 访问数组中的第3个元素，y的值为3</span></span><br><span class="line"></span><br><span class="line">numbers[<span class="number">1</span>] = <span class="number">10</span>;  <span class="comment">// 修改数组中的第2个元素，将其值改为10</span></span><br></pre></td></tr></table></figure>
<p>注意：<strong>数组的索引必须在合法的范围内，即从0到数组长度减1</strong>如果使用超出范围的索引来访问数组元素，将会导致未定义的行为，可能会访问到无效的内存地址</p>
<hr>
<h2 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h2><p>一维数组是由一组具有相同数据类型的元素组成的，这些元素按照一维的方式排列在连续的内存空间中。一维数组可以看作是一个线性的数据结构，可以通过索引来访问和操作数组中的元素。刚刚对于数组的解释全都是属于一维数组的范畴</p>
<hr>
<h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><p>二维数组是一种特殊的数组，它包含一组具有相同数据类型的元素，这些元素按照二维的方式排列在连续的内存空间中。二维数组可以看作是一个表格或矩阵，它由行和列组成。在C语言中，二维数组可以使用两个索引<strong>（或者叫下标）</strong>来访问和操作数组中的元素，一个索引<strong>（或者叫下标）</strong>表示行，另一个索引<strong>（或者叫下标）</strong>表示列。</p>
<ol>
<li><strong>二维数组的定义</strong></li>
</ol>
<p>*<em>二维数组的定义形式：</em>***数据类型 数组名[行数][列数];**<strong>数据类型表示数组中元素的数据类型，数组名是一个标识符用于表示数组的名称，行数表示二维数组的行数，列数表示二维数组的列数。</strong>定义一个包含3行4列的二维数组的语句如下：<br>int matrix[3][4];</p>
<hr>
<ol start="2">
<li><strong>二维数组的初始化</strong></li>
</ol>
<ul>
<li><p><strong>静态初始化：</strong><br>在定义时就定义了所有数据</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> str[<span class="number">2</span>][<span class="number">3</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>将所有数据写在同一花括号内：</strong></p>
</li>
</ul>
<p>系统按照下标自动自动分配行列</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> str[<span class="number">2</span>][<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;	</span><br><span class="line"><span class="type">int</span> str[<span class="number">2</span>][<span class="number">3</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;&#125;; <span class="comment">//两者均表示一个意思</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>只对部分元素赋值：</strong></li>
</ul>
<p>未赋值的元素自动赋值为 0</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> str[<span class="number">2</span>][<span class="number">3</span>] = &#123;&#123;<span class="number">1</span>&#125;,&#123;<span class="number">4</span>&#125;&#125;;</span><br><span class="line"><span class="comment">//这样表示的</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">4</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>定义时，可以对第一维不指定，但第二维必须指定：</strong><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> str[<span class="number">2</span>][<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="type">int</span> str[][<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;; 	<span class="comment">//第二维为三，总共有6个数据，所以第一维自然为二</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<ol start="3">
<li><strong>二维数组的访问</strong></li>
</ol>
<p>在C语言中，可以使用<strong>索引（或者叫下标）</strong>来访问数组中的元素。数组的<strong>索引（或者叫下标）从0开始递增</strong>，表示数组中元素的位置。*<em>访问数组元素的方式为：</em>***数组名[索引][索引]**<strong>。</strong>初始化一个包含3行4列的二维数组的语句如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> matrix[<span class="number">3</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">    &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;,</span><br><span class="line">    &#123;<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>二维数组中的元素可以通过两个索引来访问和操作。第一个索引表示行，第二个索引表示列。索引从0开始递增，表示数组中元素的位置。例如，访问二维数组中的第2行第3列的元素的语句如下：<br>int x &#x3D; matrix[1][2];		&#x2F;&#x2F;表示二维数组 matrix 中的第2行第3列的元素。<br>需要注意的是，二维数组的行数和列数是固定的，一旦定义后就不能改变。如果需要存储更多的元素，可以重新定义一个更大行数和列数的二维数组，并将原数组中的元素复制到新数组中。<br><strong>二维数组以上的多维数组同理，大差不错</strong></p>
<hr>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">str[<span class="number">1</span>] = <span class="string">&#x27;e&#x27;</span>;</span><br><span class="line">str[<span class="number">2</span>] = <span class="string">&#x27;l&#x27;</span>;</span><br><span class="line">str[<span class="number">3</span>] = <span class="string">&#x27;l&#x27;</span>;</span><br><span class="line">str[<span class="number">4</span>] = <span class="string">&#x27;o&#x27;</span>;</span><br><span class="line">str[<span class="number">5</span>] = <span class="string">&#x27;\0&#x27;</span>;	<span class="comment">//添加结束字符&#x27;\0&#x27;,表示字符串结束，马上就讲到</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br></pre></td></tr></table></figure>
<p>字符数组（字符串）变量 <strong>str</strong>，它有容量为5个字符。接下来，通过 str[0] 到 str[4] 分别赋值为字符’H’、’e’、’l’、’l’、’o’，这样就形成了一个字符串”Hello”。C语言数组的索引是从0开始的，所以str[0]表示数组中的第一个元素，即字符串的第一个字符。每个字符都用单引号括起来。</p>
<hr>
<ol>
<li><strong>字符数组的初始化</strong></li>
</ol>
<ul>
<li><strong>静态初始化：</strong></li>
</ul>
<p>直接定义好，再一一配队</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">5</span>] = &#123;<span class="string">&#x27;H&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>&#125;;</span><br><span class="line"><span class="comment">//两者同一个意思</span></span><br><span class="line"><span class="type">char</span> str[] = &#123;<span class="string">&#x27;H&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>大括号内的值按照顺序依次赋给数组中的元素。如果数组的长度小于大括号内的元素个数，会产生编译错误。如果数组的长度大于大括号内的元素个数，则剩余的元素会被自动初始化为0。</p>
<hr>
<ol>
<li><strong>字符数组的访问</strong></li>
</ol>
<p>访问字符数组时，可以使用索引来访问数组中的每个字符。索引从0开始，递增到数组长度减1。示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问单个字符</span></span><br><span class="line"><span class="type">char</span> firstChar = str[<span class="number">0</span>];  <span class="comment">// 获取第一个字符 &#x27;H&#x27;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;第一个字符：%c\n&quot;</span>, firstChar);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改单个字符</span></span><br><span class="line">str[<span class="number">0</span>] = <span class="string">&#x27;h&#x27;</span>;  <span class="comment">// 将第一个字符修改为 &#x27;h&#x27;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;修改后的字符串：%s\n&quot;</span>, str);  <span class="comment">// 输出 &quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历字符数组</span></span><br><span class="line"><span class="type">int</span> length = <span class="keyword">sizeof</span>(str) / <span class="keyword">sizeof</span>(<span class="type">char</span>);  <span class="comment">// 计算字符数组的长度</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;字符数组长度：%d\n&quot;</span>, length);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, str[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);  <span class="comment">// 输出 &quot;h e l l o&quot;</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们首先通过索引来访问字符数组 str 中的单个字符。通过使用 str[0]，我们可以获取第一个字符 ‘H’。然后，我们将 str[0] 的值修改为 ‘h’，从而将第一个字符改为小写接下来，我们使用一个循环来遍历整个字符数组。我们通过计算字符数组的长度（使用 sizeof 运算符）来确定循环的终止条件。需要注意的是，我们减去1是为了避免访问到字符串的结束标志 ‘\0’。在循环中，我们使用索引 i 来访问字符数组中的每个字符，并使用 printf 函数打印出来。最终，我们得到了字符数组中的每个字符。</p>
<hr>
<ol>
<li><strong>字符串和字符串结束标志</strong></li>
</ol>
<ul>
<li><strong>字符串结束标志</strong></li>
</ul>
<p>C语言规定，以字符 ‘\0’ 作为结束标志。如果字符数组中存在若干个字符，前面9个字符都不是空字符（’\0’），而第10个字符是 ‘\0’ ，<strong>则认为数组中有一个字符串，</strong>其有效字符为9个。意为，在遇到字符 ‘\0’ 时，表示字符串结束，把它前面的字符组成一个字符串<br>了解C语言字符串处理后，字符数组初始化方法可以多一种——字符串常量字符数组初始化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[] = &#123;<span class="string">&quot;Hello world&quot;</span>&#125;;</span><br><span class="line"><span class="comment">//同理</span></span><br><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;Hello world&quot;</span>;</span><br></pre></td></tr></table></figure>

<hr>
<ol start="2">
<li><strong>字符数组的输入输出</strong></li>
</ol>
<ul>
<li><p><strong>逐个字符输入输出，用格式符 ‘%c’:</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入一个字符串：&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;str[i]);</span><br><span class="line"><span class="keyword">if</span>(str[i] == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">str[i] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 将换行符替换为字符串结束符</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输入的字符串为：%s\n&quot;</span>, str);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;逐个字符输出字符串：&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; str[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, str[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出： 请输入一个字符串：Hello World 输入的字符串为：Hello World 逐个字符输出字符串：H e l l o W o r l d</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>将整个字符串一次性输入输出，用格式符 ‘%s’：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">char str[20];</span><br><span class="line">printf(&quot;请输入一个字符串：&quot;);</span><br><span class="line">scanf(&quot;%s&quot;, str);</span><br><span class="line">printf(&quot;输入的字符串为：%s\n&quot;, str);</span><br><span class="line">// 输出： 请输入一个字符串：Hello World 输入的字符串为：Hello</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<ol start="3">
<li><strong>字符串处理函数</strong></li>
</ol>
<ul>
<li><strong>puts 函数——输出字符串函数</strong></li>
</ul>
<p>将一个字符串（以 ‘\0’ 结束的字符序列）输出到终端</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">10</span>] = <span class="string">&quot;China&quot;</span>;</span><br><span class="line"><span class="built_in">puts</span>(str);</span><br></pre></td></tr></table></figure>
<p>输出：<br>China<br>同时，puts函数输出的字符串可以包含转义字</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;Hello\nChina&quot;</span>;</span><br><span class="line"><span class="built_in">puts</span>(str);</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello</span><br><span class="line">China</span><br></pre></td></tr></table></figure>
<p><strong>在用puts输出时将字符串结束标志’\0’转换成’\n’,即输出完字符串后换行</strong></p>
<hr>
<ul>
<li><strong>gets 函数——输入字符串函数</strong></li>
</ul>
<p>从终端输入一个字符串到字符数组，并且得到一个返回值。返回值：如果成功，返回输入的字符串；如果发生错误或到达文件结束，返回 NULL。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line">gets(str);	\\假定输入China</span><br></pre></td></tr></table></figure>
<p>输出：<br>China<br><strong>对于输入 “China”，由于最后的换行符也会被存储在数组中，所以实际上是存储了 6 个字符：’C’、’h’、’i’、’n’、’a’ 和换行符。</strong></p>
<hr>
<ul>
<li><strong>strcat函数——字符串连接函数</strong></li>
</ul>
<p>一般形式：<br>strcat(字符数组1，字符数组2);	&#x2F;&#x2F;把字符串2连接到字符串1的后面<br>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> destination[<span class="number">20</span>] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> source[] = <span class="string">&quot; World!&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">strcat</span>(destination, source);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, destination);</span><br></pre></td></tr></table></figure>
<p>输出：<br>Hello world!</p>
<hr>
<ul>
<li><strong>strcpy、strncpy函数——字符串复制函数</strong></li>
<li><strong>strcpy函数</strong></li>
</ul>
<p><strong>一般形式：</strong><br>strcpy(字符数组1，字符数组2);	&#x2F;&#x2F;将字符串2复制到字符串1中去<br>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str1[<span class="number">10</span>], str2[] = <span class="string">&quot;China&quot;</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(str1,str2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,str1);</span><br></pre></td></tr></table></figure>
<p>输出：<br>China</p>
<hr>
<ul>
<li><strong>strncpy函数</strong></li>
</ul>
<p>strncpy函数用于将一个字符串的<strong>指定长度</strong>复制到另一个字符串中。<strong>一般形式：</strong><br>strncpy(字符串1, 字符串2, 要复制的字符数);<br>strncpy函数会将源字符串的指定长度的字符复制到目标字符串中，如果源字符串的长度小于指定的字符数，则目标字符串将以结束符\0填充到指定字符数。如果源字符串的长度大于指定的字符数，则目标字符串将不会以结束符\0结尾。<strong>需要注意的是，<strong><strong>strncpy</strong></strong>函数不会自动在目标字符串的末尾添加结束符<strong><strong>\0</strong></strong>，因此在使用<strong><strong>strncpy</strong></strong>函数后，需要手动将结束符<strong><strong>\0</strong></strong>添加到目标字符串的末尾。</strong>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">char</span> str1[<span class="number">10</span>];</span><br><span class="line"><span class="type">char</span> str2[] = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strncpy</span>(str1, str2, <span class="keyword">sizeof</span>(str1)<span class="number">-1</span>);</span><br><span class="line">    str1[<span class="keyword">sizeof</span>(str1)<span class="number">-1</span>] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 手动添加结束符\0</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;strncpy: %s\n&quot;</span>, str1);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：<br>strncpy: Hello, Wo<br>在这个示例中，我们定义了一个长度为10的字符数组str1，并初始化为空字符串。我们还定义了一个字符数组str2，并初始化为”Hello, World!”。使用strncpy函数将str2字符串的前9个字符复制到str1字符串中。由于指定了目标字符串的最大长度为10，strncpy函数复制了str2字符串的前9个字符到str1字符串中，但没有添加结束符\0。因此，我们需要手动将结束符\0添加到str1字符串的最后。最后，通过printf函数打印str1字符串，输出结果为”Hello, Wo”。</p>
<hr>
<ul>
<li><strong>strcmp函数——字符串比较函数</strong></li>
</ul>
<p><strong>一般形式：</strong><br>strcmp(字符串1, 字符串2);<br>比较字符串1和字符串2，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> str2 = <span class="string">&quot;world&quot;</span>;</span><br><span class="line"><span class="built_in">strcmp</span>(str1,str2);</span><br><span class="line"><span class="built_in">strcmp</span>(<span class="string">&quot;China&quot;</span>,<span class="string">&quot;Korea&quot;</span>);</span><br><span class="line"><span class="built_in">strcmp</span>(<span class="string">&quot;China&quot;</span>,str1);</span><br></pre></td></tr></table></figure>
<p><strong>比较规则：</strong>将两字符串自左至右逐个字符相比（<strong>按ASCII码值大小比较</strong>），直到出现不同的字符或遇到 ‘\0’为止</p>
<ul>
<li>如全部字符相同，则认为两字符串相等</li>
<li>若出现不相同的字符，则以第1对不相同的字符的比较结果为准。</li>
</ul>
<p>eg：”DOG”&gt;”cat”<br><strong>比较的结果由函数值带回：</strong></p>
<ul>
<li>如字符串1与字符串2相同，则函数值为0</li>
<li>如字符串1&gt;字符串2，则函数值为一个正整数</li>
<li>如字符串1&lt;字符串2，则函数值为一个负整数</li>
</ul>
<hr>
<ul>
<li><strong>strlen 函数——测字符串长度的函数</strong></li>
</ul>
<p>一般形式：<br>strlen(字符数组);<strong>函数的值为字符串中的实际长度（不包括 ‘\0’ 在内）</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">10</span>] = <span class="string">&quot;China&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="built_in">strlen</span>(str));</span><br></pre></td></tr></table></figure>
<p>输出的结果不是10，也不是6，而是5</p>
<hr>
<ul>
<li><strong>strlwr 函数——转换为大写的函数</strong></li>
</ul>
<p>一般形式：<br>strlwr(字符串);其函数的作用是将字符串中大写字母换成小写字母</p>
<hr>
<ul>
<li><strong>strupr 函数——转换为大写的函数</strong></li>
</ul>
<p>一般形式：<br>strupr(字符串);其函数的作用是将字符串中小写字母换成大写字母</p>
<hr>
<h1 id="第7章-用函数实现模块化程序设计"><a href="#第7章-用函数实现模块化程序设计" class="headerlink" title="第7章 用函数实现模块化程序设计"></a>第7章 用函数实现模块化程序设计</h1><h2 id="为什么要用函数"><a href="#为什么要用函数" class="headerlink" title="为什么要用函数"></a>为什么要用函数</h2><p><strong>模块化程序设计的思路</strong>模块化程序设计的思路是将一个复杂的程序拆分成独立的、可重用的模块，每个模块负责实现一个特定的功能或完成一个具体的任务。例如用sin函数实现求一个数的正弦值，需要用时，直接在程序中写上sin(a)来调用系统函数库中的函数代码，执行这些代码，得到结果。<strong>好处：</strong>C语言中模块化程序设计可以使代码结构更清晰、减少代码的复杂性、提高代码的复用性、方便调试和测试，并且提高代码的可维护性。</p>
<hr>
<h2 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h2><p><strong>C语言要求，在程序中用到的所有函数，必须“先定义，后使用”</strong></p>
<ol>
<li><strong>定义函数的规则：</strong></li>
</ol>
<ul>
<li>指定函数的名字，以便以后按名调用</li>
<li>指定函数的定义，即函数返回值的类型</li>
<li>指定函数的参数的名字和类型，以便在调用函数时向它们传递数据，<strong>对无参函数不需要这个</strong></li>
<li>指定函数应当完成什么操作，即函数的功能</li>
</ul>
<hr>
<ol>
<li><strong>定义函数的方法：</strong></li>
</ol>
<ul>
<li><strong>定义无参函数</strong></li>
</ul>
<p>函数名后面的括号中是空的，没有任何参数一般形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">类型名 函数名()</span><br><span class="line">&#123;</span><br><span class="line">函数体</span><br><span class="line">&#125;</span><br><span class="line">//	或者</span><br><span class="line">类型名 函数名(void)</span><br><span class="line">&#123;</span><br><span class="line">函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello, World!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//	调用hellp函数只会输出：Hello, World!</span></span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li><strong>定义有参函数</strong></li>
</ul>
<p>函数名后面的括号中就有了形参（形式参数表列）一般形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">类型名 函数名(形参)</span><br><span class="line">&#123;</span><br><span class="line">函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li><strong>定义空函数</strong></li>
</ul>
<p>程序设计中，有时会用到一般形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类型名 函数名()</span><br><span class="line">&#123; &#125;</span><br></pre></td></tr></table></figure>
<p>空函数在初学者学习编程的过程中可能没有太多直接的用途，因为它们没有实际完成任何具体的操作或功能然而，空函数在编程中仍然有一些可以帮助初学者的用途：</p>
<ul>
<li>框架搭建：在程序的早期阶段，可以使用空函数作为某个功能的占位符。这样，你可以在函数的基础上构建程序的其他部分，并在后续逐步填充具体的功能。 </li>
<li>接口一致性：在学习面向对象编程时，接口是一种规定了类中公共方法的方式。如果你正在实现一个接口，并且某个方法对于你来说暂时没有具体的实现逻辑，你可以将其定义为空函数。这样，你可以确保你的代码与接口的规范保持一致，然后逐步实现其他相关功能。 </li>
<li>调试与测试：在调试或测试过程中，你可能需要模拟某个函数的行为，而不需要实际执行任何操作。你可以将该函数定义为空函数，以便在调试和测试过程中临时禁用该函数的功能。</li>
</ul>
<hr>
<h2 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h2><p><strong>一般形式：</strong><br>函数名 (实参列表);<br>如果是调用无参列表，则“实参列表”可以没有，但括号不能省略如果“实参列表”包含多个实参，则各参数间用逗号隔开</p>
<ol>
<li><strong>函数调用的3种形式：</strong></li>
</ol>
<ul>
<li><strong>函数调用语句：</strong></li>
</ul>
<p>把函数调用单独作为一个语句。<br>printf_ns();</p>
<ul>
<li><strong>函数表达式：</strong></li>
</ul>
<p>是表达式的一部分，来参与表达式的运算<br>c &#x3D; 2 * max(a,b);	&#x2F;&#x2F;求出a,b之间的最大值，再与2进行计算</p>
<ul>
<li><strong>函数参数：</strong></li>
</ul>
<p>函数调用作为另一个函数调用时的参数<br>m &#x3D; max(a,max(b,c));   </p>
<hr>
<ol start="2">
<li><strong>函数调用时的数据传递</strong></li>
</ol>
<ul>
<li><strong>形式参数和实际参数</strong></li>
</ul>
<p><strong>形式参数：</strong>再定义函数时函数名后面括号中的变量名称 为<strong>“形式参数”（简称“形参”）</strong>或<strong>“虚拟参数”实际参数：</strong>再主调函数中调用一个函数时，函数名后面括号中的参数称为<strong>“实际参数”（简称“实参”）</strong>使用形式参数和实际参数的代码示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 定义一个函数，使用形式参数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printNumber</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The number is: %d\n&quot;</span>, num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> number = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用printNumber函数，传递实际参数</span></span><br><span class="line">    printNumber(number);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义了一个函数printNumber，它接受一个整数形式参数num。在main函数中，我们声明了一个整数变量number并赋值为10。然后，调用printNumber函数，并将number作为实际参数传递给该函数。在函数调用过程中，实际参数number的值被复制到形式参数num中。在printNumber函数内部，我们可以使用形式参数num来访问并打印传递的实际参数的值。<strong>输出结果为：</strong><br>The number is: 10<br>在这个例子中，形式参数num是函数printNumber的虚拟参数，它在函数定义时被声明。而实际参数number是在调用函数时传递给函数的真实数据。</p>
<ul>
<li><strong>实参和形参间的数据传递</strong></li>
</ul>
<p>再调用函数过程中，系统会把实参的值传递给被调用函数的形参。或者说，形参从实参得到一个值。该值再函数调用期间有效，可以参加该函数中的运算。使用实参传递给形参的C语言代码示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个函数，使用形式参数进行运算</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">addNumbers</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line"><span class="type">int</span> sum = num1 + num2;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> number1 = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> number2 = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用addNumbers函数，将number1和number2作为实际参数传递</span></span><br><span class="line">    <span class="type">int</span> result = addNumbers(number1, number2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The sum is: %d\n&quot;</span>, result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义了一个函数addNumbers，它接受两个整数形式参数num1和num2。在main函数中，我们声明了两个整数变量number1和number2，并分别赋值为10和20。然后，我们调用addNumbers函数，并将number1和number2作为实际参数传递给该函数。在函数调用过程中，实际参数number1和number2的值被传递给形式参数num1和num2。在addNumbers函数内部，我们使用形式参数num1和num2进行加法运算，并将结果保存在sum变量中。最后，我们将sum作为返回值返回给调用者。在main函数中，我们将addNumbers函数的返回值保存在result变量中，并打印出来。输出结果为：<br>The sum is: 30</p>
<p>在例子中，实参number1和number2的值被传递给形参num1和num2，形参在函数调用期间有效，并参与了函数内部的加法运算。最后，函数的返回值被传递给了result变量。</p>
<hr>
<ol start="3">
<li><strong>函数调用的过程</strong></li>
</ol>
<ul>
<li>在定义函数中指定的形参，在未出现函数调用时，它们并不占用内存中的储存单元。在发生函数调用时，函数的形参才被临时分配内存单元</li>
<li>将实参的值传递给对应形参，让形参得到实参的值。在执行函数期间，由于形参已经有值，就可以利用形参进行有关的运算</li>
<li>通过 return 语句（后面会讲）将函数值带回到主调函数。执行 return 语句就把这个函数返回值带回主调函数 main。</li>
</ul>
<p><strong>注意，返回值的类型应与函数类型一致。</strong>如果函数不需要返回值，则不需要 return 语句。这时函数应该是 void 类型。</p>
<ul>
<li>调用结束，形参单元被释放。但实参单元仍保留并维持原值，没变。如果在执行一个被调用函数时，形参的值发生改变，不会改变主调函数的实参值。</li>
</ul>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义，计算两个整数的和</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line"><span class="type">int</span> sum = a + b;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> num1 = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> num2 = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 函数调用，将num1和num2作为实参传递给add函数</span></span><br><span class="line">    <span class="type">int</span> result = add(num1, num2);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印结果</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The sum is: %d\n&quot;</span>, result);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，首先定义了一个函数add，该函数接受两个整数作为参数，并返回它们的和。然后在main函数中声明了两个整数变量num1和num2，并将它们作为实参传递给add函数进行调用。调用结束后，将返回的结果赋值给变量result，并通过printf函数打印出来。执行上述代码，输出结果为The sum is: 30，说明函数调用和返回值传递的过程是正确的。</p>
<hr>
<ol start="4">
<li><strong>函数的返回值</strong></li>
</ol>
<p>希望通过函数调用时主调函数能得到一个确定的值，这就是<strong>函数值（函数的返回值）</strong></p>
<ul>
<li><strong>函数的返回值是通过函数中的 return 语句获得的</strong></li>
<li><strong>函数值的类型</strong></li>
<li>**在定义函数时指定的函数类型一般应该和 return语句中的表达式类型一致	**</li>
</ul>
<p>代码示例，演示了函数的返回值的获取和类型的一致性：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义，计算两个整数的和</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line"><span class="type">int</span> sum = a + b;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义，计算两个浮点数的平均值</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">average</span><span class="params">(<span class="type">float</span> a, <span class="type">float</span> b)</span> &#123;</span><br><span class="line"><span class="type">float</span> avg = (a + b) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">return</span> avg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> num1 = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> num2 = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 函数调用，将num1和num2作为实参传递给add函数，并获取返回值</span></span><br><span class="line">    <span class="type">int</span> result = add(num1, num2);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印结果</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The sum is: %d\n&quot;</span>, result);</span><br><span class="line">    </span><br><span class="line">    <span class="type">float</span> num3 = <span class="number">2.5</span>;</span><br><span class="line">    <span class="type">float</span> num4 = <span class="number">3.5</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 函数调用，将num3和num4作为实参传递给average函数，并获取返回值</span></span><br><span class="line">    <span class="type">float</span> avgResult = average(num3, num4);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印结果</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The average is: %.2f\n&quot;</span>, avgResult);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，定义了两个函数add和average，分别用于计算整数的和和浮点数的平均值。在main函数中，分别调用了这两个函数，并通过return语句获取了它们的返回值。注意，add函数返回的是int类型的值，而average函数返回的是float类型的值。执行上述代码，输出结果为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">The sum is: <span class="number">30</span></span><br><span class="line">The average is: <span class="number">3.00</span></span><br></pre></td></tr></table></figure>
<p>说明函数的返回值获取和类型的一致性是正确的。</p>
<hr>
<h2 id="函数递归"><a href="#函数递归" class="headerlink" title="函数递归"></a>函数递归</h2><p><strong>该知识点难理解，强烈建议结合例子习题理解C语言允许在调用一个函数的过程中有出现直接或间接地调用该函数本身，这种行为称为函数的递归调用</strong>在C语言中，函数递归的实现需要满足以下几个要点：</p>
<ol>
<li>基本情况（递归终止条件）：递归函数必须包含一个或多个基本情况，即递归终止条件。这些条件表示递归函数不再继续调用自身，而是直接返回一个结果。没有递归终止条件的递归函数将会无限循环调用自身，导致栈溢出。 </li>
<li>递归调用：在递归函数的定义中，通过调用自身来解决规模更小的子问题。递归调用应该在满足递归终止条件的情况下进行，以避免无限递归。 </li>
<li>问题规模的缩小：递归函数应该在每次调用自身时，通过改变输入参数的值来缩小问题的规模。这样，每次递归调用都在解决一个规模更小的子问题。</li>
</ol>
<p>下面是一个经典的递归函数示例，用于计算阶乘：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归函数，计算阶乘</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">factorial</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"><span class="comment">// 基本情况：当n为0或1时，直接返回1</span></span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归调用：将问题规模缩小，计算n的阶乘需要先计算(n-1)的阶乘</span></span><br><span class="line">    <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> num = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用递归函数计算阶乘</span></span><br><span class="line">    <span class="type">int</span> result = factorial(num);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置中文环境</span></span><br><span class="line">    setlocale(LC_ALL, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印结果</span></span><br><span class="line">    wprintf(<span class="string">L&quot;%d的阶乘是：%d\n&quot;</span>, num, result);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，定义了一个递归函数factorial，用于计算一个整数的阶乘。在函数中，首先判断输入的整数是否为0或1，如果是，则直接返回1，作为递归终止条件。否则，通过递归调用自身，将问题规模缩小为计算(n-1)的阶乘，并将结果乘以n，最终得到n的阶乘。在main函数中，我们使用setlocale函数将程序的本地化环境设置为中文环境，以支持中文输出。然后使用wprintf函数来输出中文字符串，其中的L前缀表示宽字符字符串。执行上述代码，输出结果为：<br>5的阶乘是：120<br>说明递归函数成功地计算了5的阶乘。需要注意的是，在实际应用中，递归函数可能会因为递归的深度过大而导致栈溢出，因此在设计递归函数时需要注意递归的终止条件和问题规模的缩小，以避免出现问题。</p>
<h2 id="数组作为函数参数"><a href="#数组作为函数参数" class="headerlink" title="数组作为函数参数"></a>数组作为函数参数</h2><p>数组元素也可以用作函数实参，用法与变量一致，向形参传递数组元素的值。此外，数组名也可以作实参和形参，传递的事数组第一个元素的地址。</p>
<ul>
<li><strong>数组元素作函数参数</strong></li>
</ul>
<p>数组元素可以用作函数实参，但是不能用作形参。因为形参是在函数被调用时临时分配储存单元的，不可能作为一个数组元素单独分配储存单元（数组是一个整体，在内存中占连续的一段储存单元）。在用数组元素作函数实参时，把实参的值传给形参，是“<strong>值传递</strong>”方式。数据传递的方向是<strong>从实参传到形参，单向传递。示例：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">changeValue</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">num = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="built_in">array</span>[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;调用函数前： %d\n&quot;</span>, <span class="built_in">array</span>[<span class="number">0</span>]);</span><br><span class="line">    changeValue(<span class="built_in">array</span>[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;调用函数后： %d\n&quot;</span>, <span class="built_in">array</span>[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，我们定义了一个数组 array，并将其第一个元素传递给函数 changeValue。函数 changeValue 将形参 num 的值改为 10。然而，在函数调用结束后，数组 array 的第一个元素的值并没有改变。这是因为在函数调用时，只是将数组元素的值传递给了函数的形参，而不是直接传递数组元素本身。因此，对形参的修改不会影响到原始数组。输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>总结：数组元素可以作为函数实参传递给函数，但是不能作为函数形参。函数对数组元素的修改不会影响到原始数组。</p>
<hr>
<ul>
<li><strong>一维数组名作函数参数</strong></li>
</ul>
<p>除了可以用数组元素作为函数参数外，还可以用数组名作函数参数（包括实参和形参）注意：用数组元素作实参时，向形参变量传递的事数组元素的值，而用数组名作函数实参时，向形参（数组名或指针变量）传递的事数组首元素的地址示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printArray</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> size)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">changeArray</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> size)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">arr[i] = arr[i] * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="built_in">array</span>[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;调用函数前：&quot;</span>);</span><br><span class="line">    printArray(<span class="built_in">array</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    changeArray(<span class="built_in">array</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;调用函数后：&quot;</span>);</span><br><span class="line">    printArray(<span class="built_in">array</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，我们定义了两个函数：printArray 和 changeArray。printArray 函数用于打印数组的元素，接受一个整数数组和数组大小作为参数。changeArray 函数用于将数组的每个元素乘以2，同样接受一个整数数组和数组大小作为参数。<br>在 main 函数中，我们声明了一个大小为5的整数数组 array，并将其初始化为 {1, 2, 3, 4, 5}。首先，我们调用 printArray 函数打印数组的元素，然后调用 changeArray 函数修改数组的元素。最后，我们再次调用 printArray 函数打印修改后的数组元素。<br>在函数调用时，我们将数组名 array 作为实参传递给了函数的形参，即 printArray(array, 5) 和 changeArray(array, 5)。由于数组名传递的是数组首元素的地址，函数在接收到数组名后，可以通过指针的方式访问数组的元素，并对其进行操作。输出结果：调用函数前：1 2 3 4 5调用函数后：2 4 6 8 10</p>
<hr>
<h2 id="局部变量和全局变量"><a href="#局部变量和全局变量" class="headerlink" title="局部变量和全局变量"></a>局部变量和全局变量</h2><p>定义变量可能有3种情况：</p>
<ol>
<li>在函数的开头定义</li>
<li>在函数内的复合语句内定义</li>
<li>在函数的外部定义</li>
<li><strong>作用域</strong></li>
</ol>
<p>在一个函数中定义的变量，在其他函数中能否被引用？在不同位置定义的变量，在什么范围内有有效？这就是变量的<strong>作用域</strong>的问题，每个变量都有一个作用域问题，即它们在什么范围内有效。<strong>变量的作用域从空间的角度来观察，可分为全局变量和局部变量</strong></p>
<hr>
<ol>
<li><strong>局部变量</strong></li>
</ol>
<p>局部变量是在函数或者语句块内部定义的变量，它的作用域仅限于定义它的函数或者语句块内部。局部变量在函数或者语句块执行结束后会被销毁，其占用的内存空间也会被释放。<br>例如，下面是一个定义局部变量的示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myFunction</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> x;  <span class="comment">// 定义一个局部变量x</span></span><br><span class="line">x = <span class="number">10</span>; <span class="comment">// 赋值给x</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;x = %d\n&quot;</span>, x); <span class="comment">// 输出x的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">myFunction();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，x是一个局部变量，它只在myFunction函数内部有效。当myFunction函数执行完毕后，变量x会被销毁。局部变量的作用域仅限于定义它的函数或者语句块内部。这意味着在其他函数或者语句块中无法访问到局部变量。例如，在上面的示例中，如果在main函数中尝试访问变量x，会导致编译错误。局部变量的生命周期与其作用域相对应。当程序执行到定义局部变量的语句时，会为变量分配内存空间；当变量的作用域结束时，会释放该内存空间。</p>
<hr>
<ol start="2">
<li><strong>全局变量</strong></li>
</ol>
<p>全局变量是在函数外部定义的变量，它的作用域从定义点开始，直到文件结束。全局变量可以在整个程序中被访问和使用。在C语言中，全局变量的定义通常在所有函数的外部，即在函数之外。全局变量的定义可以在任何函数之前，但是只能定义一次。<br>例如，下面是一个定义全局变量的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int globalVariable; // 定义一个全局变量</span><br><span class="line"></span><br><span class="line">void myFunction() &#123;</span><br><span class="line">globalVariable = 10; // 在函数内部访问和修改全局变量</span><br><span class="line">printf(&quot;globalVariable = %d\n&quot;, globalVariable); // 输出全局变量的值</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">myFunction();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，globalVariable是一个全局变量，它可以在myFunction函数内部访问和修改。全局变量的值在整个程序中都是可见的。全局变量的作用域从定义点开始，直到文件结束。这意味着在整个程序中的任何函数中都可以访问和使用全局变量。例如，在上面的示例中，如果在main函数中尝试访问全局变量globalVariable，是完全合法的。全局变量的生命周期与整个程序的运行时间相对应。当程序开始执行时，会为全局变量分配内存空间；当程序结束时，会释放该内存空间。</p>
<hr>
<h2 id="变量的存储方式和生存期"><a href="#变量的存储方式和生存期" class="headerlink" title="变量的存储方式和生存期"></a>变量的存储方式和生存期</h2><p><strong>变量的作用域从存在的时间（即生存期）来观察，可分为静态存储方式、动态存储方式</strong></p>
<ul>
<li><strong>静态、动态存储方式：</strong></li>
</ul>
<p><strong>静态存储方式</strong>是指在程序运行期间由系统分配固定的存储空间的方式<strong>动态存储方式</strong>是在程序运行期间根据需要进行动态的分配存储空间的方式<br>在内存中的供用户使用的存储空间可分为三部分：（1）程序区；（2）静态存储区；（3）动态存储区。<br>数据分别放在静态存储区和动态存储区中：</p>
<ul>
<li><strong>全局变量全部存放在”静态存储区“中</strong>，在程序开始执行时给全局变量分配存储区，程序执行完毕就释放。</li>
</ul>
<p>在程序执行过程中它们占据固定的存储单元，而不是动态地进行分配和释放</p>
<ul>
<li><strong>在”动态存储区“中存放以下数据：</strong></li>
</ul>
<p>（1）函数形式参数。在调用函数时给形参分配存储单元（2）函数中定义的没有用关键字static声明的变量，即自动变量（后面马上讲）（3）函数调用时的现场保护和返回地址等</p>
<hr>
<h2 id="局部变量的存储类别"><a href="#局部变量的存储类别" class="headerlink" title="局部变量的存储类别"></a>局部变量的存储类别</h2><p>在定义和声明变量和函数时，一般应同时指定其数据类型和存储类别，也可以采用默认方式指定（就是用户不指定，系统会隐含地指定为某一种存储类别）根据变量的存储类别，可以知道变量的作用域和生存区。C语言的存储变量分为自动变量（auto）、静态变量（static）、寄存器变量（register）、外部变量（extern）** 局部变量分为以下三种：**</p>
<ul>
<li><strong>自动变量（auto变量）</strong></li>
</ul>
<p>在函数中的局部变量，如果不专门声明为 static（静态）存储类别，都是动态的分配存储空间的，数据存储在动态存储区中。函数中的形参和在函数中定义的局部变量（包括在复合语句中定义的局部变量），都属于此类。调用该函数时，系统会给这些变量分配储存空间。在函数调用结束时就自动释放这些存储空间。因此这类局部变量称为<strong>自动变量</strong>。<strong>实际上，关键字 auto可以省略，不写 auto 则隐含指定为“自动存储类别”，它属于动态存储方式。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">auto</span> <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li><strong>静态局部变量（static局部变量）</strong></li>
</ul>
<p>有时希望函数中的局部变量的值在函数调用结束后不消失，而继续保留原值，其占用的储存单元不释放，在下一次在调用该函数时，该变量已有值（就是上一次调用结束时的值）。此类局部变量叫<strong>静态局部变量。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// 静态局部变量</span></span><br><span class="line">count++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Count: %d\n&quot;</span>, count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">increment(); <span class="comment">// 输出 Count: 1</span></span><br><span class="line">increment(); <span class="comment">// 输出 Count: 2</span></span><br><span class="line">increment(); <span class="comment">// 输出 Count: 3</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，increment函数内部定义了一个静态局部变量count，并初始化为0。每次调用increment函数时，count的值都会自增，并通过printf函数打印出来。由于count是静态局部变量，它的值在函数调用之间保持不变，即使increment函数被多次调用，count的值也会保持累加。因此，上述代码的输出结果将是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Count: 1</span><br><span class="line">Count: 2</span><br><span class="line">Count: 3</span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li><strong>寄存器变量（register 变量）</strong></li>
</ul>
<p>一般地，变量（包括静态存储方式和动态存储方式）的值是存放在内存中的。如果有一些变量使用频繁，为提高执行效率，允许将局部变量的值存放在CPU中的寄存器中。需要用时直接从寄存器取出参加运算，不必再到内存中去存取。以提高执行效率。这种变量叫做<strong>寄存器变量。实际上使用不多，知道有这种类别即可</strong></p>
<h2 id="全局变量存储类别"><a href="#全局变量存储类别" class="headerlink" title="全局变量存储类别"></a>全局变量存储类别</h2><p>全局变量都是存放在静态存储区中的。因此它们的生存期是固定的，存在于程序的整个运行过程。</p>
<ul>
<li><strong>在一个文件内拓展外部变量的作用域</strong></li>
</ul>
<p>如果外部变量不在文件的开头定义，其有效地作用范围值限于定义处到文件结束。在定义点之前的函数不能引用该外部变量。如果由于某种考虑，在定义之前的函数需要引用该外部变量，则应该在应用之前用关键字 <strong>extern <strong>对该变量作</strong>“外部变量声明”</strong>，表示把该外部变量的作用域扩展到此位置。有了此声明，就可以从“声明”处起，合法地使用外部变量下面是一个简单的C语言代码例子，展示了如何使用extern关键字声明变量和函数：在文件a.c中定义全局变量x：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">10</span>; <span class="comment">// 定义全局变量x</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">()</span>; <span class="comment">// 声明函数foo</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">foo(); <span class="comment">// 调用函数foo</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;x = %d\n&quot;</span>, x); <span class="comment">// 打印全局变量x的值</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在文件b.c中使用extern关键字声明变量x，并定义函数foo：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> x; <span class="comment">// 使用extern关键字声明全局变量x</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Inside foo: x = %d\n&quot;</span>, x); <span class="comment">// 打印全局变量x的值</span></span><br><span class="line">x = <span class="number">20</span>; <span class="comment">// 修改全局变量x的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中，文件a.c中定义了一个全局变量x，并声明了函数foo。文件b.c中使用extern关键字声明了变量x，并定义了函数foo。在文件a.c的main函数中，首先调用了函数foo，然后打印了全局变量x的值。在函数foo中，打印了全局变量x的值，并修改了其值为20。在编译和链接这两个文件时，编译器会在链接阶段把文件b.c中的变量x和函数foo与文件a.c中的引用关联起来，从而实现了在不同文件中共享变量和函数的功能。</p>
<ul>
<li><strong>将外部变量的作用域拓展找其他文件</strong></li>
</ul>
<p>在文件a.c中定义外部变量x：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">10</span>; <span class="comment">// 定义外部变量x</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;x = %d\n&quot;</span>, x); <span class="comment">// 打印外部变量x的值</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在文件b.c中使用extern关键字引用外部变量x：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">extern int x; // 使用extern关键字引用外部变量x</span><br><span class="line"></span><br><span class="line">void foo() &#123;</span><br><span class="line">printf(&quot;Inside foo: x = %d\n&quot;, x); // 打印外部变量x的值</span><br><span class="line">x = 20; // 修改外部变量x的值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中，文件a.c中定义了一个外部变量x，并在main函数中打印了外部变量x的值。文件b.c中使用extern关键字引用了外部变量x，并在函数foo中打印了外部变量x的值，并修改了其值为20。在编译和链接这两个文件时，编译器会在链接阶段将文件b.c中的引用与文件a.c中的定义关联起来，从而实现了在不同文件中共享外部变量的功能。</p>
<h2 id="外部函数与内部函数"><a href="#外部函数与内部函数" class="headerlink" title="外部函数与内部函数"></a>外部函数与内部函数</h2><ol>
<li><strong>内部函数</strong></li>
</ol>
<p>如果一个函数只能被本文件其他函数所调用，它称为内部函数。在定义内部函数时，在函数名和函数类型的前面加 static 即可<br>static 类型名 函数名(形参表);<br>例如，函数的首行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>;</span><br><span class="line"><span class="comment">//表示fun是一个内部函数，不能被其他文件调用</span></span><br></pre></td></tr></table></figure>
<p>内部函数又称静态函数，因为它是用 static声明的。使用内部函数，可以使函数的作用域只局限于所在文件。这样，在不同的文件中即使有同名的内部函数，也互不干扰，不必担心所用函数是否会与其他文件模块中的函数同名。</p>
<ol start="2">
<li><strong>外部函数</strong></li>
</ol>
<p>如果在定义函数时，在函数首部的最左段加关键字extern，则此函数时外部函数，可供其他文件调用。<br>extern int fun(int a,int b);<br>C语言规定，如果在定义函数时省略 extern，则默认为外部函数。</p>
<hr>
<h1 id="第8章-善于利用指针"><a href="#第8章-善于利用指针" class="headerlink" title="第8章 善于利用指针"></a>第8章 善于利用指针</h1><p><strong>本章节是C语言的重难点，多看，多练</strong></p>
<h2 id="指针的含义"><a href="#指针的含义" class="headerlink" title="指针的含义"></a>指针的含义</h2><ol>
<li><strong>数据在内存中的存储与读取</strong></li>
</ol>
<p>在程序中定义了一个变量，在对程序进行编译时，系统给这个变量分配内存单元。不同变量分配不同长度空间，在VS中，整型变量（int）分配4个字节，双精度浮点型变量（double）也分配8个字节…内存区的每一个字节有一个编号，这就是“地址”，相当与酒店里的房间号。在地址所标志的内存单元中存放的数据则是相当于酒店房间中居住的旅客。由于通过地址能找到所需的变量单元，即为<strong>地址指向该变量单元</strong>。<strong>把地址形象化地称为“指针”，</strong>能找到以它为地址的内存单元。</p>
<ol start="2">
<li><strong>直接访问与间接访问</strong></li>
</ol>
<p><strong>直接访问：</strong>直接访问是指直接使用变量名来访问变量的值。例如，<strong>int num &#x3D; 10; <strong>定义了一个整型变量num，我们可以直接使用num来访问和修改它的值。</strong>间接访问：</strong>间接访问是通过指针来访问变量的值。指针存储了一个变量的地址，通过指针我们可以间接地访问和修改该地址处的数据。例如<strong>，int _ptr &#x3D; __#__（_、&amp;符号后面马上讲到）</strong>将整型变量num的地址赋值给指针变量ptr，然后我们可以使用*ptr来访问和修改num的值。</p>
<hr>
<p><strong>举例：</strong>为将数值3送到变量中，有两种表达方式：（1）将3直接送到变量 i 所标识的单元中，如“ i &#x3D; 3; ”。（2）将3送到变量 i_pointer 所指向的单元（即变量 i 的存储单元），如“ *i_pointer &#x3D; 3; ”, 其中 *i_pointer 表示 i_pointer指向的对象<strong>指向就是通过地址来体现的</strong>，由于通过地址能找到所需的变量单元。因此说，地址指向该变量单元（如房间号指向或代表着一个房间一样，将地址形象化地称为指针）</p>
<hr>
<h2 id="指针变量"><a href="#指针变量" class="headerlink" title="指针变量"></a>指针变量</h2><p>如果有一个变量专门来存放另一变量的地址（即指针），则它称为“<strong>指针变量</strong>”。<strong>指针变量就是地址变量</strong>，用来存放地址，指针变量的值就是地址</p>
<ol>
<li><strong>定义指针变量</strong><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">类型名 *指针变量名;</span><br><span class="line"><span class="type">int</span> *pointer;</span><br><span class="line"><span class="comment">//&quot;*&quot;的位置无所谓，靠左int* pointer靠右int *pointer在中间int * pointer都行</span></span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>上例，左端的 int是在定义指针变量时必须指定的”基类型“，用来指定次指针变量可以指向的变量的类型</li>
</ul>
<p>如上例 int *pointer只能用于指向整型。</p>
<hr>
<ol start="2">
<li><strong>引用指针变量</strong></li>
</ol>
<ul>
<li><p><strong>给指针变量赋值</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;a;</span><br></pre></td></tr></table></figure>
<p>定义了一个整型变量a，并赋值为5。然后定义了一个整型指针p，并将a的地址赋给p。这样，p就指向了a的内存地址。**&amp;符号在C语言中表示取地址操作符。它用于获取变量的内存地址。在这段代码中，&amp;a表示获取变量a的内存地址，并将该地址赋给指针变量p**</p>
</li>
<li><p><strong>引用指针变量指向的变量</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,*p);</span><br><span class="line">有</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a);</span><br><span class="line"><span class="comment">//最终的输出结果为： 5  5</span></span><br></pre></td></tr></table></figure>
<p>首先定义了一个整型变量a，并赋值为5。然后定义了一个整型指针p，并将a的地址赋给p。接下来使用printf函数来输出变量的值。第一行printf语句中，使用了解引用操作符_，即_p，表示获取指针p指向的地址的值。所以输出的结果为5。第二行printf语句中，直接输出变量a的值，也是5。<strong>如果有：</strong><br>*p &#x3D; 3;<br>表示将整数 3 赋值给 p 当前所指向的变量，如果 p 指向 a，则相当于把 1 赋值给a。</p>
</li>
<li><p><strong>引用指针变量的值</strong></p>
</li>
</ul>
<p>printf(“%o”,p);<br>作用是以八进制数形式输出指针变量 p 的值，如果 p 指向了 a，就是输出了 a 的地址，即 &amp;a</p>
<hr>
<ol start="3">
<li><strong>指针变量作为函数参数</strong></li>
</ol>
<p>函数的参数不仅可以是整型，浮点型，字符型的数据，还可以是指针类型，它的作用是将一个变量的地址传送到另一个函数中。下面是一个使用指针变量作为函数参数的C语言代码例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数原型，参数为指针变量</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">changeValue</span><span class="params">(<span class="type">int</span> *ptr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;函数调用前的值：%d\n&quot;</span>, a);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用函数，传入指针变量a的地址</span></span><br><span class="line">    changeValue(&amp;a);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;函数调用后的值：%d\n&quot;</span>, a);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义，通过指针修改变量的值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">changeValue</span><span class="params">(<span class="type">int</span> *ptr)</span> &#123;</span><br><span class="line"><span class="comment">// 解引用指针，修改变量的值</span></span><br><span class="line">*ptr = <span class="number">10</span>;</span><br><span class="line">&#125;-----</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们定义了一个函数changeValue，它接受一个指针变量作为参数。在main函数中，我们定义了一个整型变量a并赋值为5。然后，我们调用changeValue函数，并传入a的地址&amp;a作为参数。在changeValue函数中，我们通过解引用指针*ptr来修改变量的值。最后，在main函数中打印修改后的a的值。输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">函数调用前的值：5</span><br><span class="line">函数调用后的值：10</span><br></pre></td></tr></table></figure>
<p>可以看到，通过指针变量作为函数参数，我们可以在函数内部修改变量的值，并且这个修改也会影响到函数外部的变量。</p>
<hr>
<h2 id="指针引用数组"><a href="#指针引用数组" class="headerlink" title="指针引用数组"></a>指针引用数组</h2><ul>
<li><strong>数组元素的指针</strong></li>
</ul>
<p>一个变量有地址，一个数组包含若干个元素，每个数组元素都在内存中占有存储单元，他们都有相应的地址。指针变量既然可以指向变量，当然也可以指向数组元素。<strong>可以用一个指针变量指向一个数组元素：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> *p;</span><br><span class="line">p = &amp;a[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<p>首先定义了一个整型数组a，并初始化为 {1, 2, 3}。然后，声明了一个整型指针变量p。接下来，将数组a的第一个元素的地址</p>
<hr>
<p>在C语言中数组名（不算形参数组名）代表数组中首元素（如a[0]）的地址因此，下面两者是等价的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p = &amp;a[<span class="number">0</span>];	<span class="comment">//设定a是数组名，p是指针变量</span></span><br><span class="line">p = a;</span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li><strong>在引用数组元素时的指针运算</strong></li>
</ul>
<p>在<strong>指针以指向一个元素时</strong>，可以对指针进行以下运算：在引用数组元素时，可以对指针进行一些运算操作。下面是一些常见的指针运算：</p>
<ol>
<li>加一个整数：可以使用指针加上一个整数来访问数组中的下一个元素。例如，p + 1会将指针p向后移动一个位置，指向数组中的下一个元素。 </li>
<li>减一个整数：类似地，可以使用指针减去一个整数来访问数组中的前一个元素。例如，p - 1会将指针p向前移动一个位置，指向数组中的前一个元素。 </li>
<li>自增运算：可以使用自增运算符++来将指针向后移动一个位置。例如，p++或++p会将指针p指向数组中的下一个元素。 </li>
<li>自减运算：类似地，可以使用自减运算符–来将指针向前移动一个位置。例如，p–或–p会将指针p指向数组中的前一个元素。 </li>
<li>两个指针相减：当两个指针指向同一数组中的元素时，可以使用减法运算符-来计算它们之间的距离（以元素个数为单位）。例如，p2 - p1会得到两个指针之间的元素个数。</li>
</ol>
<p>需要注意的是<strong>，只有在指针指向同一数组中的元素时，</strong>才能进行指针的加减运算和两个指针的相减运算。否则，结果将是未定义的。</p>
<hr>
<ul>
<li><strong>通过指针引用数组元素</strong></li>
</ul>
<p><strong>引用数组元素可以用下标法(p &#x3D; &amp;a[0])，也可以用指针法及通过指向数组元素的指针找到所需元素。</strong>下面是使用C语言代码通过指针引用数组元素的两种方法：下标法和指针法。嗯<strong>下标法：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a[%d] = %d\n&quot;</span>, i, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，使用了一个for循环来遍历数组a。通过下标i来访问数组元素，即a[i]。通过循环迭代，可以依次引用数组中的每个元素。<br><strong>指针法：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> *p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (p = &amp;a[<span class="number">0</span>]; p &lt; &amp;a[<span class="number">3</span>]; p++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;*p = %d\n&quot;</span>, *p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，定义了一个整型指针变量p，并将其初始化为指向数组a的第一个元素的地址，即&amp;a[0]。然后，使用for循环来遍历数组a。通过指针p来引用数组元素，即*p。在每次循环迭代中，指针p向后移动一个位置，指向下一个数组元素。</p>
<hr>
<h2 id="指针引用字符串"><a href="#指针引用字符串" class="headerlink" title="指针引用字符串"></a>指针引用字符串</h2><ol>
<li><strong>字符串的引用方式</strong></li>
</ol>
<p>在C语言中，字符串可以通过两种方式进行引用：作为字符数组和作为字符指针。<strong>字符数组方式引用字符串：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">char</span> str1[] = <span class="string">&quot;Hello, World!&quot;</span>;  <span class="comment">// 字符数组方式引用字符串</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str1: %s\n&quot;</span>, str1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，使用字符数组str1来引用字符串”Hello, World!”。字符数组会在内存中分配足够的空间来存储字符串的每个字符，字符串的末尾会自动添加一个空字符\0作为结束符。<strong>字符指针方式引用字符串：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">char</span> *str2 = <span class="string">&quot;Hello, World!&quot;</span>;  <span class="comment">// 字符指针方式引用字符串</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str2: %s\n&quot;</span>, str2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，使用字符指针str2来引用字符串”Hello, World!”。字符指针指向字符串的第一个字符，字符串的末尾仍然有一个空字符\0作为结束符。需要注意的是，字符数组方式引用字符串可以修改字符串的内容，<strong>而字符指针方式引用字符串不能修改字符串的内容。</strong>例如，下面的代码会导致编译错误：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">char</span> *str = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    str[<span class="number">0</span>] = <span class="string">&#x27;h&#x27;</span>;  <span class="comment">// 编译错误，字符指针方式引用的字符串是只读的</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<ol>
<li><strong>字符指针作函数参数</strong></li>
</ol>
<p>在C语言中，可以使用字符指针作为函数的参数来传递字符串。通过传递字符指针，函数可以访问并操作字符串的内容。下面是一个例子，演示了如何使用字符指针作为函数参数来打印字符串：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printString</span><span class="params">(<span class="type">char</span> *str)</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">char</span> *str = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">printString(str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，定义了一个函数printString，它接受一个字符指针参数str，并使用printf函数打印字符串。在main函数中，定义了一个字符指针str，并将其作为参数传递给printString函数。需要注意的是，<strong>字符指针作为函数参数传递时，函数内部不能修改指针的值</strong>，也不能修改指针所指向的字符串的内容。如果需要在函数内部修改字符串的内容，可以使用字符数组作为函数参数。</p>
<hr>
<h2 id="指向函数的指针"><a href="#指向函数的指针" class="headerlink" title="指向函数的指针"></a>指向函数的指针</h2><ol>
<li><strong>函数的指针</strong></li>
</ol>
<p>在程序中定义了一个函数，在编译时会把函数的源代码转换为可执行代码并分配一段存储空间。这段存储空间有一个起始地址，也称为函数的入口地址。每次调用函数时都从该地址入口开始执行此段函数代码。<strong>函数名代表函数的起始地址函数名就是函数的指针，它代表函数的起止地址</strong><br>int (*p)(int,int);<br>定义P是一个指向函数的指针变量可以指向函数类型为整型且有两个整型参数的函数</p>
<hr>
<ol start="2">
<li><strong>用函数指针变量调用函数</strong></li>
</ol>
<p>要使用函数指针变量调用函数，可以直接使用函数指针变量的名称后跟括号，类似于调用函数的语法。下面是一个示例代码，演示了如何使用函数指针变量调用函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">subtract</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> (*funcPtr)(<span class="type">int</span>, <span class="type">int</span>);  <span class="comment">// 声明一个指向函数的指针变量</span></span><br><span class="line"></span><br><span class="line">    funcPtr = add;  <span class="comment">// 将函数的地址赋值给函数指针变量</span></span><br><span class="line">    <span class="type">int</span> result = funcPtr(<span class="number">5</span>, <span class="number">3</span>);  <span class="comment">// 通过函数指针调用函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Result of add: %d\n&quot;</span>, result);</span><br><span class="line"></span><br><span class="line">    funcPtr = subtract;  <span class="comment">// 可以将函数指针指向不同的函数</span></span><br><span class="line">    result = funcPtr(<span class="number">5</span>, <span class="number">3</span>);  <span class="comment">// 再次通过函数指针调用函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Result of subtract: %d\n&quot;</span>, result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们定义了两个函数add和subtract，它们分别接受两个整数参数并返回整数。然后，我们声明了一个指向函数的指针变量funcPtr，它接受两个整数参数并返回整数。我们将add函数的地址赋值给funcPtr，然后通过funcPtr(5, 3)调用add函数，并将结果存储在result变量中。接着，我们将subtract函数的地址赋值给funcPtr，再次通过funcPtr(5, 3)调用subtract函数，并将结果存储在result变量中。</p>
<hr>
<ol>
<li>** 定义和使用指向函数的指针变量**</li>
</ol>
<p>定义指向函数的指针变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">返回类型 (*指针变量名)(参数类型<span class="number">1</span>, 参数类型<span class="number">2</span>, ...);</span><br><span class="line"><span class="type">int</span> (*p)(<span class="type">int</span>,<span class="type">int</span>);</span><br></pre></td></tr></table></figure>
<p>下面是一个示例代码，演示了如何定义和使用指向函数的指针变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">subtract</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// 声明一个指向函数的指针变量</span></span><br><span class="line"><span class="type">int</span> (*funcPtr)(<span class="type">int</span>, <span class="type">int</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将函数的地址赋值给函数指针变量</span></span><br><span class="line">    funcPtr = add;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用函数指针调用函数</span></span><br><span class="line">    <span class="type">int</span> result = funcPtr(<span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;add函数的结果: %d\n&quot;</span>, result);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将函数的地址赋值给函数指针变量</span></span><br><span class="line">    funcPtr = subtract;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用函数指针调用函数</span></span><br><span class="line">    result = funcPtr(<span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;subtract函数的结果: %d\n&quot;</span>, result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们定义了两个函数add和subtract，它们分别接受两个整数参数并返回整数。然后，我们声明了一个指向函数的指针变量funcPtr，它接受两个整数参数并返回整数。我们将add函数的地址赋值给funcPtr，然后通过funcPtr调用add函数，并将结果存储在result变量中。接着，我们将subtract函数的地址赋值给funcPtr，再次通过funcPtr调用subtract函数，并将结果存储在result变量中。</p>
<hr>
<h2 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h2><p>在C语言中，动态内存分配是通过malloc、calloc、realloc和free函数来实现的。这些函数可以帮助我们在程序运行时动态地分配和释放内存。</p>
<ol>
<li><p><strong>malloc</strong> <strong>函数</strong>用于分配指定字节数的内存，并返回一个指向分配内存的指针。它的基本用法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span>* ptr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">5</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用分配的内存</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>calloc</strong> <strong>函数</strong>与malloc函数类似，但它会将分配的内存块的每个字节都初始化为零。它的基本用法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span>* ptr = (<span class="type">int</span>*)<span class="built_in">calloc</span>(<span class="number">5</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用分配的内存</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>realloc</strong> <strong>函数</strong>用于重新分配已经分配的内存块的大小。如果原内存块的大小不够，realloc函数会重新分配更大的内存块，并将原内存块的内容复制到新内存块中。如果原内存块的大小过大，realloc函数会缩小内存块的大小。它的基本用法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span>* ptr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">5</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用分配的内存</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重新分配内存块的大小为10个整数</span></span><br><span class="line">    ptr = (<span class="type">int</span>*)<span class="built_in">realloc</span>(ptr, <span class="number">10</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存重新分配失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用重新分配的内存</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>free</strong> <strong>函数</strong>用于释放之前通过malloc、calloc或realloc函数分配的内存。它的基本用法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span>* ptr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">5</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用分配的内存</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，动态分配的内存需要手动释放，否则会导致内存泄漏。在释放内存后，不能再使用已释放的内存，否则会导致未定义的行为。</p>
</li>
</ol>
<hr>
<h1 id="第9章-用户自己建立数据类型"><a href="#第9章-用户自己建立数据类型" class="headerlink" title="第9章 用户自己建立数据类型"></a>第9章 用户自己建立数据类型</h1><h2 id="结构体变量"><a href="#结构体变量" class="headerlink" title="结构体变量"></a>结构体变量</h2><ol>
<li><strong>结构体定义</strong></li>
</ol>
<p>结构体由多个成员变量组成，每个成员变量可以是不同的数据类型。通过结构体，我们可以将相关的数据组织在一起，方便管理和操作。结构体的定义使用<strong>struct****关键字</strong>，后面跟着结构体的名称和成员变量的列表。<strong>结构体的定义：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构体名</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">成员列表;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="type">float</span> gpa;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，我们定义了一个名为Student的结构体，它有三个成员变量：name、age和gpa。name是一个字符数组，用于存储学生的姓名；age是一个整数，用于存储学生的年龄；gpa是一个浮点数，用于存储学生的平均成绩。<strong>结构体成员变量的运用：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个结构体类型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line"><span class="type">int</span> id;</span><br><span class="line"><span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// 声明一个结构体变量并初始化</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stu1</span> =</span> &#123;<span class="number">1</span>, <span class="string">&quot;Alice&quot;</span>, <span class="number">18</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问结构体成员变量并输出</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;学生ID：%d\n&quot;</span>, stu1.id);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;学生姓名：%s\n&quot;</span>, stu1.name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;学生年龄：%d\n&quot;</span>, stu1.age);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改结构体成员变量的值</span></span><br><span class="line">    stu1.age = <span class="number">19</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出修改后的结果</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;学生年龄（修改后）：%d\n&quot;</span>, stu1.age);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>我们可以通过结构体的名称和成员变量的名称来访问结构体的成员。例如，下面是一个使用结构体的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line"><span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="type">float</span> gpa;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">student1</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置学生的信息</span></span><br><span class="line">    <span class="built_in">strcpy</span>(student1.name, <span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">    student1.age = <span class="number">20</span>;</span><br><span class="line">    student1.gpa = <span class="number">3.5</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印学生的信息</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;姓名：%s\n&quot;</span>, student1.name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;年龄：%d\n&quot;</span>, student1.age);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;平均成绩：%f\n&quot;</span>, student1.gpa);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，我们首先定义了一个名为student1的结构体变量。然后，我们使用.运算符来访问结构体的成员变量，并设置其值。最后，我们打印了学生的姓名、年龄和平均成绩。</p>
<hr>
<p><strong>typedef关键字</strong>typedef关键字是C语言中用来给已经存在的数据类型起一个新的名字的关键字。通过使用typedef关键字，可以为已有的数据类型定义一个新的名称，使得使用该数据类型时更加方便和直观。<strong>typedef关键字通常与结构体一起使用，用于给结构体类型定义一个新的名称</strong>。typedef关键字的语法格式如下：<br>typedef 原类型名 新类型名;<br>例如，可以使用typedef关键字为结构体类型定义一个新的名称，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="type">int</span> year;</span><br><span class="line"><span class="type">int</span> month;</span><br><span class="line"><span class="type">int</span> day;</span><br><span class="line">&#125; Date;</span><br></pre></td></tr></table></figure>
<p>在上述示例中，使用typedef关键字为结构体类型定义了一个新的名称Date。之后可以直接使用Date作为结构体类型的名称，而不需要每次都使用struct关键字。</p>
<hr>
<ol>
<li><strong>定义结构体类型变量</strong></li>
</ol>
<p>当我们定义结构体类型变量时，可以使用3种方法：<strong>a. 先声明结构体类型，在定义该类型的变量：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line"><span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="type">float</span> gpa;</span><br><span class="line">&#125;;	<span class="comment">// 先声明结构体类型</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">student1</span>;</span>  <span class="comment">// 再定义结构体变量</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(student1.name, <span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">    student1.age = <span class="number">20</span>;</span><br><span class="line">    student1.gpa = <span class="number">3.5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;姓名：%s\n&quot;</span>, student1.name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;年龄：%d\n&quot;</span>, student1.age);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;平均成绩：%f\n&quot;</span>, student1.gpa);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，我们首先使用struct关键字声明了一个名为Student的结构体类型。然后，在main函数中，我们定义了一个名为student1的结构体变量，该变量的类型是之前声明的Student结构体类型。<strong>b.在声明类型的同时定义变量</strong>就是将结构体的声明和初始化合并在一起。示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明结构体类型的同时定义结构体变量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> y;</span><br><span class="line">&#125; p1 = &#123;<span class="number">10</span>, <span class="number">20</span>&#125;; <span class="comment">// 定义并初始化结构体变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// 使用已定义的结构体变量</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;坐标点：(%d, %d)\n&quot;</span>, p1.x, p1.y);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在示例中，我们定义了一个结构体类型struct Point，其中包含两个整型成员变量x和y。而在结构体类型的声明之后，我们紧接着定义了一个结构体变量p1，并使用初始化列表对其成员变量进行了赋值。<strong>c.不指定类型名而直接定义结构体类型变量</strong>可以通过使用匿名结构体类型直接定义结构体类型变量，而<strong>不需要指定类型名。</strong>这样的结构体类型被称为匿名结构体。示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// 直接定义匿名结构体类型的变量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> y;</span><br><span class="line">&#125; p1 = &#123;<span class="number">10</span>, <span class="number">20</span>&#125;; <span class="comment">// 定义并初始化匿名结构体变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用已定义的匿名结构体变量</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;坐标点：(%d, %d)\n&quot;</span>, p1.x, p1.y);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在示例中，我们没有显式地声明一个具名的结构体类型，而是直接定义了一个匿名的结构体类型，并创建了一个匿名结构体变量p1。同样，我们也可以在定义时使用初始化列表对其成员变量进行赋值。值得注意的是，匿名结构体类型仅在定义它的作用域内有效。这意味着，我们无法在其他位置复用或引用这个结构体类型，也不能通过typedef为其定义一个类型名。</p>
<hr>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">结构体类型 数组名[数组长度];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125; Point;</span><br><span class="line"></span><br><span class="line">Point points[<span class="number">3</span>];</span><br></pre></td></tr></table></figure>
<p>结构体数组的应用：常规结构体数组应用的示例，假设我们要管理学生信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">100</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> gpa;</span><br><span class="line">&#125; Student;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Student students[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入学生信息</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入学生 %d 的信息:\n&quot;</span>, i+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;姓名: &quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, students[i].name);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;年龄: &quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;students[i].age);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;GPA: &quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>, &amp;students[i].gpa);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出学生信息</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;学生 %d 的信息:\n&quot;</span>, i+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;姓名: %s\n&quot;</span>, students[i].name);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;年龄: %d\n&quot;</span>, students[i].age);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;GPA: %.2f\n&quot;</span>, students[i].gpa);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个示例中，我们定义了一个名为 Student 的结构体类型，其中包含了学生的姓名、年龄和 GPA（平均绩点）信息。在 main 函数中，我们声明了一个名为 students 的结构体数组，数组长度为 3。然后，我们使用一个循环来输入每个学生的详细信息，并将其存储到对应的结构体数组元素中。最后，我们再次使用循环遍历结构体数组，并输出每个学生的详细信息。运行该程序，你将被要求依次输入每个学生的姓名、年龄和 GPA，然后程序将输出输入的学生信息。</p>
<h2 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h2><p>如果把一个结构体变量的起始地址存放在一个指针变量中，这个指针变量就指向该结构体变量<strong>两种不同的访问结构体成员的方式：</strong>** 点操作符 ****.**<strong>：</strong>使用点操作符 . 可以直接访问结构体变量的成员。这种方式适用于直接访问结构体变量。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125; Point;</span><br><span class="line"></span><br><span class="line">Point p1;</span><br><span class="line">p1.x = <span class="number">3</span>;</span><br><span class="line">p1.y = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<p>**箭头操作符 ****-&gt;**<strong>：</strong>当使用指针指向结构体变量时，需要使用箭头操作符 -&gt; 来访问结构体变量的成员。这种方式适用于访问结构体指针指向的结构体变量。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125; Point;</span><br><span class="line"></span><br><span class="line">Point p1;</span><br><span class="line">Point *ptr = &amp;p1;</span><br><span class="line">ptr-&gt;x = <span class="number">3</span>;</span><br><span class="line">ptr-&gt;y = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<p><strong>注意，只有当我们使用指针指向结构体变量时，才需要使用箭头操作符</strong> <strong>-&gt;</strong> <strong>。如果我们直接使用结构体变量，则应使用点操作符</strong> <strong>.</strong></p>
<ol>
<li><strong>指向结构体变量、数组的指针</strong></li>
</ol>
<p>指向结构体对象指着变量即可指向结构体变量，也可指向结构体数组中的元素指针变量的基类型必须与结构体变量的类型相同。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> *<span class="title">pt</span>;</span>	</span><br><span class="line"><span class="comment">//pt 可以指向 struct Student类型的变量或数组元素</span></span><br></pre></td></tr></table></figure>
<p><strong>指向结构体变量的指针</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125; Point;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Point p1 = &#123;<span class="number">5</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    Point *ptr = &amp;p1;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Point p1: x = %d, y = %d\n&quot;</span>, ptr-&gt;x, ptr-&gt;y);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们定义了一个结构体类型 Point，并创建了一个结构体变量 p1。然后，我们定义了一个指向 Point 类型的指针 ptr，并将其指向结构体变量 p1。通过指针 ptr，我们可以访问结构体变量 p1 的成员。<strong>指向结构体数组中元素的指针</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125; Point;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Point arr[<span class="number">3</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>&#125;, &#123;<span class="number">5</span>, <span class="number">6</span>&#125;&#125;;</span><br><span class="line">    Point *ptr = arr;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Point 1: x = %d, y = %d\n&quot;</span>, ptr-&gt;x, ptr-&gt;y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Point 2: x = %d, y = %d\n&quot;</span>, (ptr+<span class="number">1</span>)-&gt;x, (ptr+<span class="number">1</span>)-&gt;y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Point 3: x = %d, y = %d\n&quot;</span>, (ptr+<span class="number">2</span>)-&gt;x, (ptr+<span class="number">2</span>)-&gt;y);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们定义了一个包含三个元素的结构体数组 arr。然后，我们定义了一个指向 Point 类型的指针 ptr，并将其指向结构体数组的第一个元素 arr[0]。通过指针 ptr 可以访问结构体数组中的元素，并通过 ptr+1 和 ptr+2 可以访问数组的下一个元素。</p>
<hr>
<ol>
<li><strong>结构体变量的指针作函数参数</strong></li>
</ol>
<p>当我们想要在函数中修改结构体变量的值时，可以通过将结构体变量的指针作为函数的参数传递，从而达到修改结构体变量的目的。示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125; Point;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">modifyPoint</span><span class="params">(Point *ptr)</span> &#123;</span><br><span class="line">    ptr-&gt;x = <span class="number">7</span>;</span><br><span class="line">    ptr-&gt;y = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Point p1 = &#123;<span class="number">5</span>, <span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Before modification: x = %d, y = %d\n&quot;</span>, p1.x, p1.y);</span><br><span class="line">    <span class="comment">// 输出 &quot;Before modification: x = 5, y = 10&quot;</span></span><br><span class="line"></span><br><span class="line">    modifyPoint(&amp;p1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;After modification: x = %d, y = %d\n&quot;</span>, p1.x, p1.y);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出 &quot;After modification: x = 7, y = 10&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们定义了一个结构体类型 Point，并在 modifyPoint 函数中接受一个 Point 类型的指针作为参数。在 modifyPoint 函数中，通过箭头操作符 -&gt; 修改了指针指向的结构体变量 ptr 的成员值。在 main 函数中，我们创建了一个 Point 类型的结构体变量 p1，然后通过 modifyPoint(&amp;p1) 将 p1 的地址作为参数传递给 modifyPoint 函数。在函数调用后，p1 的成员值被修改为 7 和 10。所以，通过将结构体变量的指针作为函数参数，我们可以在函数中直接修改结构体变量的值。</p>
<hr>
<h2 id="指针处理链表"><a href="#指针处理链表" class="headerlink" title="指针处理链表"></a>指针处理链表</h2><p>:::info <strong>该章节所涉及的链表均为单链表</strong> :::</p>
<ol>
<li><strong>链表定义</strong></li>
</ol>
<p>链表（<strong>单向链表</strong>）是一种常见的数据结构，用于存储和组织数据。<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xykcola.site/blogPics/post/202405/202405271428503.png">链表开头有一个头指针变量（Head），存放一个地址（1249），该地址指向一个元素（A）。链表末尾有一个尾指针变量，存放“NULL”，表示空地址，链表到此结束<strong>除了头尾指针外，链表中每一个元素称为“结点”，每个结点包括两部分：</strong>（1）数据域：用户需要用的实际数据（上图中的A、B、C、D）。（2）指针域：下一个结点的地址（1356、1475、1021)。从上例得知，Head指向第1个元素，第1个元素又指向第2个元素…直到最后一个元素，该元素不在指向其他元素，只存放一个空地址，链表结束。</p>
<ul>
<li>链表中的各元素在内存中的地址可以是不连续的</li>
<li>要找某一元素，必须先找到上一个元素，根据他提供的下一个地址才能找到下一个元素</li>
<li>如果不提供“头指针”(head)，则整个链表都无法访问</li>
</ul>
<hr>
<ol start="2">
<li><strong>C语言表示链表</strong></li>
</ol>
<p>链表这种数据结构，显然是指针加结构体最合适</p>
<ul>
<li><strong>定义单链表的节点结构体</strong><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;           <span class="comment">// 数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span>  <span class="comment">// 指向下一个节点的指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
上述代码定义了一个单链表的节点结构体 struct Node，它包含两个成员变量：int data：用于存储节点的数据。struct Node* next：用于指向下一个节点的指针。它是一个指针类型的成员变量，指向 struct Node 类型的节点。通过这个节点结构体，我们可以创建单链表的节点，并使用 data 成员变量存储节点的数据，使用 next 成员变量指向下一个节点。</li>
</ul>
<hr>
<ul>
<li><strong>建立简单的静态列表</strong></li>
</ul>
<p>通过一个例子来说明如何<strong>建立</strong>和<strong>输出一个简单链表：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>	//声明结构体类型<span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">float</span> score;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">a</span>, <span class="title">b</span>, <span class="title">c</span>, *<span class="title">head</span>, *<span class="title">p</span>;</span> <span class="comment">//定义3个结构体变量a, b, c 和结构体指针变量*head, *p</span></span><br><span class="line">    a.num = <span class="number">101</span>; a.score = <span class="number">90</span>;</span><br><span class="line">    b.num = <span class="number">102</span>; b.score = <span class="number">88</span>;</span><br><span class="line">    c.num = <span class="number">103</span>; c.score = <span class="number">85</span>;	<span class="comment">//分别对结构体变量a,b,c赋值</span></span><br><span class="line">    </span><br><span class="line">    head = &amp;a;		<span class="comment">//结点a的起始地址赋值给头指针head</span></span><br><span class="line">    a.next = &amp;b;	<span class="comment">//结点b的起始地址赋值给a结点的next成员</span></span><br><span class="line">    b.next = &amp;c;	<span class="comment">//结点c的起始地址赋值给b结点的next成员</span></span><br><span class="line">    c.next = <span class="literal">NULL</span>;	<span class="comment">//结点c的next被赋值NULL，表示不存放任何结点地址</span></span><br><span class="line">    p = head;		<span class="comment">//使p指向head头指针</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %0.1f\n&quot;</span>,p-&gt;num,p-&gt;score);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码定义了一个结构体类型 struct Student，它包含三个成员变量：</p>
<ul>
<li>int num：用于存储学生的学号。</li>
<li>float score：用于存储学生的分数。</li>
<li>struct Student *next：用于指向下一个学生节点的指针。这里使用了自引用的方式，使得可以构建出一个链表结构。</li>
</ul>
<p>在 main() 函数中，首先建了三个结构体变量 a、b 和 c，并给它们分别赋值，表示三个学生的学号和分数。然后，通过将 a.next、b.next 和 c.next 分别赋值为 &amp;b、&amp;c 和 NULL，将这三个节点串联成一个链表。头指针 head 被赋值为 &amp;a，即指向链表的第一个节点。然后定义了一个指针变量 p，将它初始化为 head。接下来，使用 do-while 循环遍历链表并打印每个节点的学号和分数。这里使用 printf() 函数打印输出。最后，返回 0，表示程序执行成功结束。运行上述代码，输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">101  90.0</span><br><span class="line">102  88.0</span><br><span class="line">103  85.0</span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li><strong>建立动态链表</strong></li>
</ul>
<p>所谓动态链表是指在程序执行过程中，从无到有地建立起一个链表，即一个一个地开辟结点和输入各结点数据，并建立起前后相连的关系</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;malloc.h&quot;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;  <span class="comment">//给int取别名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个单链表模板</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	ElemType data;      <span class="comment">//数据域</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">next</span>;</span>  <span class="comment">//指针域，指向下一个“相邻”的单链表</span></span><br><span class="line">&#125;SlinkNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个空的单链表（由L指向它），即头结点，带头结点，data数据域没有值，next指针域为空</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitList</span><span class="params">(SlinkNode*&amp; L)</span> <span class="comment">//（括号内为指针变量的引用，不看*就是普通变量，加上就是指针变量）</span></span><br><span class="line">&#123;</span><br><span class="line">	L = (SlinkNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SlinkNode));</span><br><span class="line">	L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁线性表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DestroyList</span><span class="params">(SlinkNode*&amp; L)</span></span><br><span class="line">&#123;</span><br><span class="line">	SlinkNode* pre = L;              <span class="comment">//单链表的头结点“L”传给pre</span></span><br><span class="line">	SlinkNode* p = pre-&gt;next;     <span class="comment">//p指向着pre的下一个单链表</span></span><br><span class="line">	<span class="keyword">while</span> (p != <span class="literal">NULL</span>)                <span class="comment">//只要p不指向尾结点，就一直重复</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">free</span>(pre);                      <span class="comment">//每动一步，就释放pre指向的一个数据结点的空间，即销毁了一个数据结点</span></span><br><span class="line">		pre = p;                        <span class="comment">//再让pre指向下一个数据结点，也就是p所指向的</span></span><br><span class="line">		p = p-&gt;next;                  <span class="comment">//紧接着p移动，指向下下一个数据结点</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">free</span>(pre);                         <span class="comment">//p已经指向了尾结点，释放pre指向的最后一个的数据结点，做到销毁整个单链表</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求线性表的长度</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">GetLength</span><span class="params">(SlinkNode* L)</span> <span class="comment">//该单链表的头结点“L”</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	SlinkNode* p = L-&gt;next;  <span class="comment">//让p指向L指向的该单链表的首结点，因为只计算除头尾结点之外的数据结点的长度</span></span><br><span class="line">	<span class="keyword">while</span> (p != <span class="literal">NULL</span>)          <span class="comment">//只要p不指向尾结点，就一直执行</span></span><br><span class="line">	&#123;</span><br><span class="line">		i++;						 <span class="comment">//i++记录长度</span></span><br><span class="line">		p = p-&gt;next;            <span class="comment">//让p指向下一个数据结点</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> i;                     <span class="comment">//记录结束，返回i的值，即该单链表的长度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求线性表中第i个元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">GetElem</span><span class="params">(SlinkNode* L, <span class="type">int</span> i, ElemType&amp; e)</span> <span class="comment">// 该单链表的头结点“L”，要找的第i个元素位置， 要找的元素位置上的值e</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> j = <span class="number">0</span>;                         <span class="comment">//j为计数，从0加到第i个，因为首结点不算，所以是0，加一个数据结点就+1（从头结点开始，j = 0 / 从数据结点开始，j = 1）</span></span><br><span class="line">	SlinkNode* p = L;             <span class="comment">//让p指向L指向的该单链表的首结点，因为头尾结点数据域没有值</span></span><br><span class="line">	<span class="keyword">if</span> (i &lt;= <span class="number">0</span>)                        <span class="comment">//判断数字i是否合理</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; j &lt; i)  <span class="comment">//p不指向尾结点，且计数j不大于等于i，才能继续下去</span></span><br><span class="line">	&#123;                                    <span class="comment">//情况1，p指向尾结点了，都没值可用了，退出循环</span></span><br><span class="line">		j++;                            <span class="comment">//情况2，j都等于i了，到第i个位置了，退出循环</span></span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">NULL</span>)                 <span class="comment">//循环结束，只要p都指向尾结点了，就是说没e值可用，说明没找到   </span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span>                               <span class="comment">//否则就是找到了</span></span><br><span class="line">	&#123;</span><br><span class="line">		e = p-&gt;data;                <span class="comment">//把p指向的数据结点的数据域的值传给e，实时更新主函数的e值，因为是 ElemType&amp; e，这个“&amp;”</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按e值查找是第几个位置</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Locate</span><span class="params">(SlinkNode* L, ElemType e)</span>   <span class="comment">//该单链表的头结点“L”，要的找在单链表中什么位置的值e（看看e在什么位置）</span></span><br><span class="line">&#123;</span><br><span class="line">	SlinkNode* p = L-&gt;next;                 <span class="comment">//让p指向L指向的该单链表的首结点</span></span><br><span class="line">	<span class="type">int</span> j = <span class="number">1</span>;                                     <span class="comment">//设为1，直接先找第1个位置（从头结点开始，j = 0 / 从数据结点开始，j = 1）</span></span><br><span class="line">	<span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; p-&gt;data != e)</span><br><span class="line">	&#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">		j++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">NULL</span>)                             <span class="comment">//p指向尾结点了，证明没有找到</span></span><br><span class="line">		<span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">else</span>                                           <span class="comment">//否则就是找到了，返回第j个值</span></span><br><span class="line">		<span class="keyword">return</span> (j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">InsElem</span><span class="params">(SlinkNode*&amp; L, ElemType x, <span class="type">int</span> i)</span> <span class="comment">// 该单链表的头结点“L”，插入结点的数据域的值x，要插入的第i个位置</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> j = <span class="number">0</span>;                                                 <span class="comment">//（从头结点开始，j = 0 / 从数据结点开始，j = 1）</span></span><br><span class="line">	SlinkNode* p = L;                                     <span class="comment">//把该单链表的头结点“L”传给p                               </span></span><br><span class="line">	SlinkNode* s;</span><br><span class="line">	<span class="keyword">if</span> (i &lt;= <span class="number">0</span>)                                               <span class="comment">//判断第i个位置是否合理</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; j &lt; i - <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		j++;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		s = (SlinkNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SlinkNode));</span><br><span class="line">		s-&gt;data = x;</span><br><span class="line">		s-&gt;next = p-&gt;next;</span><br><span class="line">		p-&gt;next = s;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">DelElem</span><span class="params">(SlinkNode*&amp; L, <span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">	SlinkNode* p = L;</span><br><span class="line">	SlinkNode* q;</span><br><span class="line">	<span class="keyword">if</span> (i &lt;= <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; j &lt; i - <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		j++;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		q = p-&gt;next;</span><br><span class="line">		<span class="keyword">if</span> (q == <span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			p-&gt;next = q-&gt;next;</span><br><span class="line">			<span class="built_in">free</span>(q);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出线性表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DispList</span><span class="params">(SlinkNode* L)</span></span><br><span class="line">&#123;</span><br><span class="line">	SlinkNode* p = L-&gt;next;</span><br><span class="line">	<span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, p-&gt;data);</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	ElemType e;</span><br><span class="line">	SlinkNode* L;</span><br><span class="line">	InitList(L);</span><br><span class="line">	InsElem(L, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">	InsElem(L, <span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line">	InsElem(L, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">	InsElem(L, <span class="number">5</span>, <span class="number">4</span>);</span><br><span class="line">	InsElem(L, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">	InsElem(L, <span class="number">2</span>, <span class="number">6</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;线性表：&quot;</span>); DispList(L);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;长度：%d\n&quot;</span>, GetLength(L));</span><br><span class="line">	i = <span class="number">3</span>; GetElem(L, i, e);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;第%d个元素：%d\n&quot;</span>, i, e);</span><br><span class="line">	e = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;元素%d是第%d个元素\n&quot;</span>, e, Locate(L, e));</span><br><span class="line">	i = <span class="number">4</span>; <span class="built_in">printf</span>(<span class="string">&quot;删除第%d个元素\n&quot;</span>, i);</span><br><span class="line">	DelElem(L, i);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;线性表：&quot;</span>); DispList(L);</span><br><span class="line">	DestroyList(L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">线性表：131542</span><br><span class="line">长度：6</span><br><span class="line">第3个元素：1</span><br><span class="line">元素1是第1个元素</span><br><span class="line">删除第4个元素</span><br><span class="line">线性表：13142</span><br></pre></td></tr></table></figure>
<h2 id="共用体类型"><a href="#共用体类型" class="headerlink" title="共用体类型"></a>共用体类型</h2><p>共用体（Union）是一种特殊的数据类型，它允许在相同的内存位置存储不同的数据类型。共用体的内存大小取决于其中最大的成员的大小。共用体的成员可以是不同的数据类型，但是在同一时间只能存储其中的一个成员值。当一个成员值被赋值给共用体时，其他成员值都会被覆盖。共用体的使用可以节省内存空间，因为共用体只会占用足够存储最大成员的内存空间。然而，由于共用体的成员共享同一块内存空间，因此对一个成员的修改会影响其他成员的值。</p>
<ul>
<li><p><strong>定义共用体：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">union 共用体名</span><br><span class="line">&#123;</span><br><span class="line">	成员列表</span><br><span class="line">&#125;变量列表;</span><br></pre></td></tr></table></figure>
</li>
<li><p>声明类型同时定义变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="type">float</span> f;</span><br><span class="line">&#125;a,b,c;</span><br></pre></td></tr></table></figure>
</li>
<li><p>类型声明与定义变量分开：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="type">float</span> f;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Data</span> <span class="title">a</span>, <span class="title">b</span>, <span class="title">c</span>;</span></span><br><span class="line"><span class="comment">//先声明一个union Data类型，再将a，b，c定义为union Data类型的变量</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<ul>
<li><strong>共同体类型的引用</strong></li>
</ul>
<p>对于共用体的成员引用，应使用共用体变量名和成员名之间的** . 运算符** 进行引用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">data</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">float</span> f;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">data</span> <span class="title">d</span>;</span></span><br><span class="line">    </span><br><span class="line">    d.i = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;d.i = %d\n&quot;</span>, d.i);</span><br><span class="line">    </span><br><span class="line">    d.f = <span class="number">3.14</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;d.f = %f\n&quot;</span>, d.f);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">strcpy</span>(d.str, <span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;d.str = %s\n&quot;</span>, d.str);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们定义了一个共用体data，它有三个成员：整型i、浮点型f和字符数组str。在main函数中，我们声明了一个共用体变量d，然后通过d.i、d.f和d.str来分别访问共用体的不同成员。对于共用体的成员访问，不需要使用.运算符，而是直接使用共用体变量名和成员名之间的.运算符。这是因为共用体的不同成员共享同一块内存空间。因此，对一个成员的修改会影响其他成员的值。在使用共用体时，需要确保对共用体的成员的访问是有意义的，并且不会引起意外的结果。</p>
<hr>
<ul>
<li><p><strong>共用体类型数据的特点</strong></p>
<ul>
<li><strong>同一个内存段可以用来存放几种不同类型的成员，但在每一瞬间只能存放其中一个成员，而不是同时存放几个</strong><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="type">float</span> f;</span><br><span class="line">&#125;a;</span><br><span class="line">a.i = <span class="number">97</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a.i);			<span class="comment">//输出整数97</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,a.ch);		<span class="comment">//输出字符&#x27;a&#x27;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f&quot;</span>,a.f);			<span class="comment">//输出实数0.000000</span></span><br></pre></td></tr></table></figure>
在代码中，a.i &#x3D; 97;将整数值97赋给了共用体的整型成员i。因此，printf(“%d”, a.i);会输出整数97。接下来，printf(“%c”, a.ch);尝试输出共用体的字符成员ch。由于共用体的不同成员共享同一块内存空间，整型成员i的值97被解释（ASCII表）为字符’a’，因此输出字符’a’。最后，printf(“%f”, a.f);尝试输出共用体的浮点型成员f。由于共用体的不同成员共享同一块内存空间，整型成员i的值97被解释为浮点数0.000000，因此输出实数0.000000。这个例子展示了共用体的一个重要特性：不同类型的成员共享同一块内存空间。这意味着对一个成员的修改可能会影响其他成员的值。在使用共用体时，需要小心确保对共用体的成员的访问是有意义的，并且不会引起意外的结果。</li>
</ul>
</li>
<li><p><strong>可以对共用体变量初始化，但初始化表中只能有一个常量</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="type">float</span> f;	</span><br><span class="line">&#125;a = &#123;<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>, <span class="number">1.5</span>&#125;;						<span class="comment">//不能初始化3个成员，它们是占用同一个存储单元的</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Data</span> <span class="title">a</span> =</span> &#123;<span class="number">16</span>&#125;;					<span class="comment">//正确，对第1个成员初始化</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Data</span> <span class="title">a</span> =</span> &#123;.ch = <span class="string">&#x27;j&#x27;</span>&#125;;		<span class="comment">//C99允许对指定的一个成员初始化</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>共用体变量中起作用的成员是最后一次被赋值的成员，在对共用体变量中的一个成员赋值后，原有变量存储单元中的值就取代</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="type">float</span> f;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">Data</span> <span class="title">d</span>;</span></span><br><span class="line">    </span><br><span class="line">    d.i = <span class="number">97</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;d.i = %d\n&quot;</span>, d.i);   <span class="comment">// 输出整数97</span></span><br><span class="line">    </span><br><span class="line">    d.ch = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;d.ch = %c\n&quot;</span>, d.ch); <span class="comment">// 输出字符&#x27;a&#x27;</span></span><br><span class="line">    </span><br><span class="line">    d.f = <span class="number">3.14</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;d.f = %f\n&quot;</span>, d.f);   <span class="comment">// 输出实数3.140000</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><p>如果一个变量只用几种可能的值，则可以定义为<strong>枚举类型（enum）</strong>，所谓枚举就是指把可能的值一一列举出来，变量的值只限于列举出来的值的范围内</p>
<ul>
<li><strong>枚举类型定义：</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum 枚举名 </span><br><span class="line">&#123;</span><br><span class="line">	枚举元素列表</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Weekday</span> &#123;</span></span><br><span class="line">    Monday,</span><br><span class="line">    Tuesday,</span><br><span class="line">    Wednesday,</span><br><span class="line">    Thursday,</span><br><span class="line">    Friday,</span><br><span class="line">    Saturday,</span><br><span class="line">    Sunday</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
在上面的代码中，我们定义了一个名为Weekday的枚举类型，它包含了一周的所有工作日和周末。枚举常量的默认值从0开始自增，因此Monday的值为0，Tuesday的值为1，以此类推。枚举类型定义后，我们可以声明枚举类型的变量，并将其赋值为枚举常量。例如：<br>enum Weekday today &#x3D; Tuesday;<br>在上面的代码中，我们声明了一个名为today的枚举类型变量，并将其赋值为Tuesday枚举常量。我们还可以通过枚举常量的名称来访问其对应的值。例如：<br>printf(“Today is %d\n”, today);<br>上述代码将输出Today is 1，因为Tuesday的值为1。枚举类型还可以与switch语句一起使用，以便根据枚举变量的值执行相应的操作。例如：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (today) &#123;</span><br><span class="line">    <span class="keyword">case</span> Monday:</span><br><span class="line">    <span class="keyword">case</span> Tuesday:</span><br><span class="line">    <span class="keyword">case</span> Wednesday:</span><br><span class="line">    <span class="keyword">case</span> Thursday:</span><br><span class="line">    <span class="keyword">case</span> Friday:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;It&#x27;s a weekday\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Saturday:</span><br><span class="line">    <span class="keyword">case</span> Sunday:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;It&#x27;s a weekend\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Invalid day\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<strong>综合案例：</strong>示例：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Month</span> &#123;</span></span><br><span class="line">    January = <span class="number">1</span>,</span><br><span class="line">    February,</span><br><span class="line">    March,</span><br><span class="line">    April,</span><br><span class="line">    May,</span><br><span class="line">    June,</span><br><span class="line">    July,</span><br><span class="line">    August,</span><br><span class="line">    September,</span><br><span class="line">    October,</span><br><span class="line">    November,</span><br><span class="line">    December</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Date</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> day;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Month</span> <span class="title">month</span>;</span></span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printDate</span><span class="params">(<span class="keyword">struct</span> Date date)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d/%d/%d\n&quot;</span>, date.day, date.month, date.year);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Date</span> <span class="title">today</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter day: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;today.day);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter month (1-12): &quot;</span>);</span><br><span class="line">    <span class="type">int</span> month;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;month);</span><br><span class="line">    today.month = (<span class="keyword">enum</span> Month)month;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter year: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;today.year);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Today&#x27;s date is: &quot;</span>);</span><br><span class="line">    printDate(today);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在上面的代码中，我们定义了一个枚举类型Month，用于表示一年中的月份。每个月份都被赋予一个整数值，从1开始自增。然后，我们定义了一个结构体Date，它包含了一个整型的day、一个枚举类型的month和一个整型的year。在main函数中，我们声明了一个名为today的结构体变量，并通过用户输入来初始化其中的成员。最后，我们调用printDate函数来打印今天的日期。该函数接受一个Date类型的参数，并按照day&#x2F;month&#x2F;year的格式打印日期。</li>
</ul>
<h1 id="第10章-对文件的输入输出"><a href="#第10章-对文件的输入输出" class="headerlink" title="第10章 对文件的输入输出"></a>第10章 对文件的输入输出</h1><h2 id="C文件基本知识"><a href="#C文件基本知识" class="headerlink" title="C文件基本知识"></a>C文件基本知识</h2><ul>
<li><strong>什么是文件</strong></li>
</ul>
<p>在程序设计中，主要用到两种文件：<br><strong>程序文件：</strong> 例如源程序文件（.c）、目标文件（.obj）、可执行文件（.exe）<br><strong>数据文件：</strong> 文件的内容不是程序，而是供程序运营时读写的数据，如在程序运行过程中输出到磁盘（或其他外部设备）的数据，或在程序运行过程中供读入的数据。如一批学生的成绩数据…<strong>本章主要讨论的数据文件</strong></p>
<hr>
<p>在以前的章节里，所处理的数据的输入输出，都是以终端为对象的，即从终端的键盘输入数据，运行结果输出到终端显示器上。实际上，常常需要将一些数据输出到磁盘上保存起来，以后需要时再从磁盘中输入到计算机内存。这就是<strong>磁盘文件统一文件处理：</strong>从操作系统的角度看，每一个与主机相连的输入输出设备都看作一个文件。操作系统把各种设备都统一作为文件来处理。例如，终端键盘是输入文件，显示屏和打印机是输出文件<strong>文件：在C语言中，文件是一种用于存储和读取数据的抽象概念。文件可以是磁盘上的实际文件，也可以是输入&#x2F;输出设备（如键盘、显示器）的抽象表示。</strong></p>
<hr>
<p><strong>文件名：</strong> 一个文件要有一个唯一的文件标识，以便用户识别和引用。</p>
<ul>
<li><strong>文件标识包括3部分：</strong></li>
</ul>
<p><strong>1、文件路径	2、文件名主干 3、文件后缀</strong>文件路径表示文件在外部存储设备中的位置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">D:\CC\temp\file.dat</span><br><span class="line">文件路径：D:\CC\temp</span><br><span class="line">文件名主干：file</span><br><span class="line">文件后缀：.dat</span><br></pre></td></tr></table></figure>
<p>表示文件 file.dat 存放在D盘中的CC目录下的temp子目录下面方便起见，文件标识常被称为文件名</p>
<hr>
<p><strong>文件缓冲区：</strong>指的就是系统自动地在内存区为程序中每一个正在使用的文件开辟一个文件缓冲区。从内存向磁盘输出数据必须先送到内存中的缓冲区，装满缓冲区后才一起送到磁盘去。如果从磁盘向计算机读入数据，则一次从磁盘文件将一批数据输入到内存缓冲区中（充满缓冲区）然后再从缓冲区逐个地将数据送到程序数据区（给程序变量）<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xykcola.site/blogPics/post/202405/202405271428771.png"></p>
<hr>
<p><strong>文件指针类型：</strong>文件类型指针是C语言中用于操作文件的一种指针类型。它可以指向一个已经打开的文件，通过该指针可以对文件进行读取、写入、移动指针位置等操作。文件类型指针的声明方式如下：<br>FILE <em>fp;<br>其中，FILE是C语言中定义的文件类型，fp是一个指向FILE类型的指针。在声明文件类型指针时，需要包含stdio.h头文件，该头文件中包含了对文件类型的定义。文件类型指针的声明方式与其他指针类型的声明方式相同，都是通过在变量名前面加上类型修饰符</em>来声明一个指针变量。例如，FILE *fp;声明了一个名为fp的文件类型指针变量。在声明文件类型指针时，可以不进行初始化，即不指向任何文件。在需要打开文件之前，可以将文件类型指针赋值为NULL，表示该指针不指向任何有效的文件。例如，FILE *fp &#x3D; NULL;声明了一个名为fp的文件类型指针变量，并将其初始化为NULL。需要注意的是，文件类型指针只能指向已经打开的文件，不能直接指向文件名或文件路径。要打开一个文件，并将文件类型指针指向该文件，需要使用fopen函数。</p>
<hr>
<h2 id="打开与关闭文件"><a href="#打开与关闭文件" class="headerlink" title="打开与关闭文件"></a>打开与关闭文件</h2><ol>
<li><strong>fopen 函数打开数据文件</strong></li>
</ol>
<ul>
<li><strong>fopen 函数调用方式</strong></li>
</ul>
<p>fopen(文件名，使用文件方式);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FILE *fp;</span><br><span class="line">fp = fopen(&quot;al&quot;, &quot;r&quot;);</span><br></pre></td></tr></table></figure>
<p>声明了一个名为fp的文件类型指针，并使用fopen函数打开了一个名为al的文件，打开模式为只读模式。</p>
<ul>
<li><strong>使用文件方式：</strong></li>
</ul>
<p>上例中的“r”就是使用文件方式的一种</p>
<table>
<thead>
<tr>
<th><strong>文件使用方式</strong></th>
<th><strong>含 义</strong></th>
<th><strong>如果指定文件不存在</strong></th>
</tr>
</thead>
<tbody><tr>
<td>r 只读</td>
<td>为了输入数据，</td>
<td></td>
</tr>
<tr>
<td>打开一个已存在的文本文件</td>
<td>出错</td>
<td></td>
</tr>
<tr>
<td>w 只写</td>
<td>为了输出数据，</td>
<td></td>
</tr>
<tr>
<td>打开一个文本文件</td>
<td>建立新文件</td>
<td></td>
</tr>
<tr>
<td>a 追加</td>
<td>向文本文件尾添加数据</td>
<td>出错</td>
</tr>
<tr>
<td>rb 只读</td>
<td>为了输入数据，打开一个二进制文件</td>
<td>出错</td>
</tr>
<tr>
<td>wb 只写</td>
<td>为了输出数据，打开一个二进制文件</td>
<td>建立新文件</td>
</tr>
<tr>
<td>ab 追加</td>
<td>向二进制文件尾添加数据</td>
<td>出错</td>
</tr>
<tr>
<td>r+ 读写</td>
<td>为了读和写，打开一个文本文件</td>
<td>出错</td>
</tr>
<tr>
<td>w+ 读写</td>
<td>为了读和写，建立一个新的文本文件</td>
<td>建立新文件</td>
</tr>
<tr>
<td>a+ 读写</td>
<td>为了读和写，打开一个文本文件</td>
<td>出错</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th><strong>rb+ 读写</strong></th>
<th><strong>为了读和写，打开一个文本文件</strong></th>
<th><strong>出错</strong></th>
</tr>
</thead>
<tbody><tr>
<td>wb+ 读写</td>
<td>为了读和写，建立一个新的二进制文件</td>
<td>建立新文件</td>
</tr>
<tr>
<td>ab+ 读写</td>
<td>为读写打开一个二进制文件</td>
<td>出错</td>
</tr>
</tbody></table>
<hr>
<ol start="2">
<li><strong>fclose 函数关闭文件</strong></li>
</ol>
<p>fclose函数用于关闭一个已打开的文件。它的作用和意义如下：</p>
<ol>
<li><strong>释放资源</strong>：当我们打开一个文件时，操作系统会为该文件分配一些资源，如文件描述符等。当我们不再需要该文件时，通过调用fclose函数来关闭文件，可以释放这些资源，以便其他程序或操作系统可以使用它们。</li>
<li><strong>保存文件</strong>：在关闭文件之前，fclose函数会将文件缓冲区中的数据写入到磁盘上的文件中。这样可以确保在关闭文件之后，文件中的数据已经被正确保存，而不会丢失或损坏。</li>
<li><strong>刷新缓冲区</strong>：在关闭文件之前，fclose函数会刷新文件缓冲区，即将缓冲区中的数据写入到文件中。这样可以确保文件中的数据与缓冲区中的数据同步，避免数据丢失或不一致的情况。</li>
</ol>
<p>需要注意的是，如果在关闭文件之后，我们仍然尝试对已关闭的文件进行读写操作，将会导致未定义的行为。因此，在关闭文件之后，我们应该确保不再对该文件进行任何操作。<br>fopen和fclose函数以不同的方式打开和关闭文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 &quot;r&quot; 模式打开文件，以只读方式打开</span></span><br><span class="line">    fp = fopen(<span class="string">&quot;example.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无法打开文件 example.txt\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件操作...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    fclose(fp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 &quot;w&quot; 模式打开文件，以写入方式打开</span></span><br><span class="line">    fp = fopen(<span class="string">&quot;output.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无法打开文件 output.txt\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件操作...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    fclose(fp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 &quot;a&quot; 模式打开文件，以追加方式打开</span></span><br><span class="line">    fp = fopen(<span class="string">&quot;log.txt&quot;</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无法打开文件 log.txt\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件操作...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    fclose(fp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先使用fopen函数以只读方式打开文件example.txt，然后进行一些文件操作，最后使用fclose函数关闭文件。接下来，我们使用fopen函数以写入方式打开文件output.txt，进行一些文件操作，然后使用fclose函数关闭文件。最后，我们使用fopen函数以追加方式打开文件log.txt，进行一些文件操作，然后使用fclose函数关闭文件。</p>
<h2 id="文件字符读写"><a href="#文件字符读写" class="headerlink" title="文件字符读写"></a>文件字符读写</h2><ol>
<li><strong>fgetc 函数</strong></li>
</ol>
<p>调用方式：<br>fgetc(fp);<br>从fp指向的文件读入一个字符返回值：读成功，带回所读的字符，失败则返回文件结束标志EOF（即-1）</p>
<hr>
<ol start="2">
<li><strong>fputc 函数</strong></li>
</ol>
<p>调用方式：<br>fputc(ch, fp);<br>把字符 ch 写到文件指针变量 fp 所指向的文件中返回值：输出成功，返回值就是输出的字符输出失败，则返回EOF（即-1）<br>使用fgetc和fputc函数进行示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *fp1, *fp2;</span><br><span class="line">    <span class="type">int</span> ch;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开输入文件</span></span><br><span class="line">    fp1 = fopen(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp1 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无法打开输入文件 input.txt\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开输出文件</span></span><br><span class="line">    fp2 = fopen(<span class="string">&quot;output.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp2 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无法打开输出文件 output.txt\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从输入文件读取字符，然后写入输出文件</span></span><br><span class="line">    <span class="keyword">while</span> ((ch = fgetc(fp1)) != EOF) &#123;</span><br><span class="line">        fputc(ch, fp2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    fclose(fp1);</span><br><span class="line">    fclose(fp2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先使用fopen函数以只读方式打开输入文件input.txt，然后使用fopen函数以写入方式打开输出文件output.txt。接下来，我们使用fgetc函数从输入文件中读取一个字符，并将其作为int类型的返回值存储在变量ch中。然后，我们使用fputc函数将字符ch写入输出文件。通过循环重复以上步骤，直到到达输入文件的末尾。最后，我们使用fclose函数关闭输入文件和输出文件。</p>
<hr>
<h2 id="文件字符串读写"><a href="#文件字符串读写" class="headerlink" title="文件字符串读写"></a>文件字符串读写</h2><ol>
<li><strong>fgets 函数</strong></li>
</ol>
<ul>
<li>调用形式：</li>
</ul>
<p>fgets(str, n, fp);</p>
<ul>
<li>功能：</li>
</ul>
<p>从 fp 指向的文件读入一个长度为（n -1）的字符串，存放带字符数组中 str 中</p>
<ul>
<li>返回值：</li>
</ul>
<p>读成功，返回地址 str ，失败则返回 NULL</p>
<ol start="2">
<li><strong>fputs 函数</strong></li>
</ol>
<ul>
<li>调用形式：</li>
</ul>
<p>fputs(str, fp);</p>
<ul>
<li>功能：</li>
</ul>
<p>把 str 所指向的字符串写到文件指针变量 fp 所指向的文件中</p>
<ul>
<li>返回值：</li>
</ul>
<p>输出成功，返回 0；否则返回非0值</p>
<hr>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数：写入文件</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">writeFile</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename, <span class="type">const</span> <span class="type">char</span>* content)</span> &#123;</span><br><span class="line">    FILE* file = fopen(filename, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无法打开文件\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fputs</span>(content, file);</span><br><span class="line">    fclose(file);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数：读取文件</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">readFile</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename)</span> &#123;</span><br><span class="line">    FILE* file = fopen(filename, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无法打开文件\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">while</span> (fgets(buffer, <span class="keyword">sizeof</span>(buffer), file) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fclose(file);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* filename = <span class="string">&quot;example.txt&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* content = <span class="string">&quot;你好，世界！&quot;</span>;</span><br><span class="line"></span><br><span class="line">    writeFile(filename, content);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;成功写入文件\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;读取到的文件内容：\n&quot;</span>);</span><br><span class="line">    readFile(filename);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义了两个函数：writeFile用于将字符串写入文件，readFile用于从文件中读取内容并打印出来。在writeFile函数中，我们使用fputs函数将内容写入文件。在readFile函数中，我们使用fgets函数逐行读取文件内容，并将每行内容打印出来。在main函数中，我们首先调用writeFile将字符串”你好，世界！”写入名为”example.txt”的文件中，然后调用readFile从文件中读取内容，并打印出来。</p>
<h2 id="格式化方式读写文本文件"><a href="#格式化方式读写文本文件" class="headerlink" title="格式化方式读写文本文件"></a>格式化方式读写文本文件</h2><p>在C语言中，是可以对文件进行格式化输入输出的，即用到 fprintf函数和 fscanf函数作用和prinf、scanf类似，但读写的对象是文件而不是终端</p>
<ul>
<li>调用方式：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fprintf(文件指针, 格式符字符串, 输出表列);</span><br><span class="line">fscanf(文件指针, 格式字符串, 输入表列);</span><br></pre></td></tr></table></figure>
举例：<br>fprintf(fp,”%d,%6.2f”,i,f);<br>将 int 型变量 i 和 float 型变量 f 的值按%d和%6.2f的格式输出到 fp 指向的文件中<br>fscanf(fp,”%d,%f”,&amp;i,&amp;f);<br>从fp指向的文件中读取数据，并将其存储在变量i和f中。</li>
</ul>
<h2 id="二进制文件数据块读写"><a href="#二进制文件数据块读写" class="headerlink" title="二进制文件数据块读写"></a>二进制文件数据块读写</h2><p>在程序中不仅需要一次输入输出一个数据，而且常常需要一次输入输出一组数据（如数组或结构体变量的值）即用到 fread 函数和 fwrite 函数，在读写时是以二进制形式进行的。在向磁盘写数据时，直接将内存中一组数据原封不动、不加转换地复制到磁盘文件上，在读入时也是将磁盘文件中若干字节的内容一批读入内存</p>
<ul>
<li>调用形式：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fread(buffer, size, count, fp);</span><br><span class="line">fwrite(buffer, size, count, fp);</span><br></pre></td></tr></table></figure>
<strong>buffer：</strong>是一个地址。对fread来说，它是用来存放从文件读入的数据的存储区的地址。对fwrite来说，它是要把此地址开始的存储区中的数据向文件输出。<strong>size：</strong>要读写的字节数。<strong>count：</strong>要读写多少个数据项（每个数据项长度为size）<strong>fp：</strong>FILE类型指针</li>
</ul>
<hr>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">100</span>];</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开文件以进行读取</span></span><br><span class="line">    fp = fopen(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无法打开文件\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从文件中读取数据到缓冲区</span></span><br><span class="line">    count = fread(buffer, <span class="keyword">sizeof</span>(<span class="type">char</span>), <span class="number">100</span>, fp);</span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;成功读取 %d 个字符\n&quot;</span>, count);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;读取的内容是: %s\n&quot;</span>, buffer);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;读取失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    fclose(fp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开文件以进行写入</span></span><br><span class="line">    fp = fopen(<span class="string">&quot;output.txt&quot;</span>, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无法打开文件\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将缓冲区中的数据写入文件</span></span><br><span class="line">    count = fwrite(buffer, <span class="keyword">sizeof</span>(<span class="type">char</span>), count, fp);</span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;成功写入 %d 个字符\n&quot;</span>, count);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;写入失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    fclose(fp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先使用fread函数从一个名为”data.txt”的文件中读取最多100个字符到缓冲区中然后，使用fwrite函数将缓冲区中的数据写入一个名为”output.txt”的文件中最后，打印出成功读取和写入的字符数。</p>
<hr>
<h2 id="随机读写数据文件"><a href="#随机读写数据文件" class="headerlink" title="随机读写数据文件"></a>随机读写数据文件</h2><p>不同于文件进行顺序读写，随机访问读写不是按数据在文件中的物理位置次序进行读写而是可以对任何位置上的数据进行访问</p>
<ol>
<li><strong>文件位置标记及其定位</strong></li>
</ol>
<ul>
<li><strong>文件位置标记</strong></li>
</ul>
<p>件位置标记是指在文件中标记当前读写位置的指针。它用于记录文件中当前操作的位置在文件中的偏移量，以便随时定位到文件的特定位置。文件位置标记通常由文件指针表示，文件指针是一个指向FILE结构体的指针。在打开文件时，文件指针会被初始化为文件的起始位置，随着读写操作的进行，文件指针会自动更新。通过文件位置标记，我们可以在文件中进行随机访问读写，不需要按照数据在文件中的物理位置次序进行操作。可以根据需要，将文件指针定位到任何位置，然后进行读写操作。</p>
<ul>
<li><strong>文件位置标记的定位</strong><ul>
<li><strong>用 rewind 函数使文件位置标记指向文件开头</strong></li>
</ul>
</li>
</ul>
<p>rewind 函数的作用是使文件位置标记重新返回文件的开头，次函数没有返回值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *file = fopen(<span class="string">&quot;example.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无法打开文件。\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读取文件内容</span></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">100</span>];</span><br><span class="line">    fgets(buffer, <span class="keyword">sizeof</span>(buffer), file);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;重置前：%s&quot;</span>, buffer);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重置文件位置标记到文件起始位置</span></span><br><span class="line">    rewind(file);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重新读取文件内容</span></span><br><span class="line">    fgets(buffer, <span class="keyword">sizeof</span>(buffer), file);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;重置后：%s&quot;</span>, buffer);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    fclose(file);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个示例打开一个名为”example.txt”的文件，并从文件中读取一行内容。然后，使用rewind函数将文件位置标记重置为文件的起始位置，再次读取文件内容并打印出来。这样就可以看到在重新读取文件内容之前，文件位置标记已经回到了文件的起始位置。</p>
<ul>
<li><strong>用 fseek 函数改变文件位置标记</strong></li>
</ul>
<p>fseek函数用于将文件指针定位到特定位置。调用形式：<br>int fseek(FILE *stream, long offset, int origin);</p>
<ul>
<li>stream：指向要操作的文件的指针。</li>
<li>offset：偏移量，可以是正数、负数或零。正数表示向文件末尾方向移动，负数表示向文件起始位置方向移动，零表示不移动。</li>
<li>origin：起始位置，可以是以下值之一：<ul>
<li>SEEK_SET：从文件起始位置开始计算偏移量。</li>
<li>SEEK_CUR：从当前位置开始计算偏移量。</li>
<li>SEEK_END：从文件末尾位置开始计算偏移量。</li>
</ul>
</li>
</ul>
<p>fseek函数的返回值为0表示成功，非零值表示失败。fseek函数的作用是根据指定的偏移量和起始位置将文件指针定位到特定位置。偏移量可以是正数、负数或零，用于指定相对于起始位置的移动距离。起始位置可以是SEEK_SET（从文件起始位置开始计算偏移量）、SEEK_CUR（从当前位置开始计算偏移量）或SEEK_END（从文件末尾位置开始计算偏移量）。使用fseek函数可以实现以下功能：</p>
<ul>
<li>将文件指针移动到文件的起始位置、当前位置或末尾位置。</li>
<li>在文件中定位到特定位置进行读写操作。</li>
<li>跳过指定数量的字节或记录。</li>
</ul>
<p>需要注意的是，fseek函数在定位文件指针时可能会受到一些限制。例如，如果文件是以文本模式（而不是二进制模式）打开的，则fseek函数可能无法准确地定位到指定的位置。此外，对于某些类型的文件（如终端设备），fseek函数可能无法正常工作。在使用fseek函数之前，需要确保文件已经成功打开，并且需要检查函数的返回值以确定是否定位成功。如果fseek函数返回非零值，则表示定位失败，可能是由于文件指针超出了文件的范围或其他原因导致的。</p>
<hr>
<ol>
<li><strong>随机读写</strong></li>
</ol>
<p>有了 rewind 和 fseek 函数就可以实现随机读写的操作了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *file = fopen(<span class="string">&quot;example.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无法打开文件。\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用fseek将文件指针定位到文件末尾</span></span><br><span class="line">    fseek(file, <span class="number">0</span>, SEEK_END);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取文件大小</span></span><br><span class="line">    <span class="type">long</span> size = ftell(file);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;文件大小：%ld 字节\n&quot;</span>, size);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用fseek将文件指针定位到文件起始位置</span></span><br><span class="line">    fseek(file, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读取文件内容</span></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">100</span>];</span><br><span class="line">    fgets(buffer, <span class="keyword">sizeof</span>(buffer), file);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;重置前：%s&quot;</span>, buffer);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用rewind将文件指针重置到文件起始位置</span></span><br><span class="line">    rewind(file);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重新读取文件内容</span></span><br><span class="line">    fgets(buffer, <span class="keyword">sizeof</span>(buffer), file);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;重置后：%s&quot;</span>, buffer);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    fclose(file);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先使用fseek函数将文件指针定位到文件末尾，然后使用ftell函数获取文件的大小，并将其打印出来。接下来，我们使用fseek函数将文件指针定位到文件起始位置，然后使用fgets函数读取文件的第一行内容并打印出来。最后，我们使用rewind函数将文件指针重置到文件起始位置，再次使用fgets函数读取文件的第一行内容并打印出来。</p>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="http://cdn.xykcola.site/blogPics/element/1712495829972.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="http://cdn.xykcola.site/blogPics/element/1712495829972.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">这不是Cola</div><div class="post-copyright__author_desc">今天也想见到你</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://blog.xykcola.site/2024/03/31/C%20%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://blog.xykcola.site/2024/03/31/C%20%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/')">C 语言笔记</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://cdn.xykcola.site/blogPics/element/common/qrcode-wechat.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xykcola.site/blogPics/element/common/qrcode-wechat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.xykcola.site/blogPics/element/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xykcola.site/blogPics/element/common/qrcode-alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://blog.xykcola.site/2024/03/31/C%20%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=C 语言笔记&amp;url=https://blog.xykcola.site/2024/03/31/C%20%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/&amp;pic=https://cdn.xykcola.site/blogPics/post/202405/202405271431216.jpg" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.xykcola.site" target="_blank">这不是Cola</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/C%E8%AF%AD%E8%A8%80/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>C语言<span class="tagsPageCount">1</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://cdn.xykcola.site/blogPics/post/202405/202405271431216.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/03/30/test/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xykcola.site/blogPics/post/202405/202405271547540.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">生活不易，小狗叹气</div></div></a></div><div class="next-post pull-right"><a href="/2024/04/02/Node_install/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xykcola.site/blogPics/post/202405/202405271602052.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Node.js的下载及安装</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i><span> 评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)">匿名评论</a><a href="/privacy" style="margin-left: 4px">隐私政策</a></div><div class="comment-tips" id="comment-tips"><span>✅ 你无需删除空行，直接评论以获取最佳展示效果</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="http://cdn.xykcola.site/blogPics/element/1712495829972.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/24/64e6ce9c507bb.png" alt="status"/></div></div><div class="author-info__description"><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">这有关于<b style="color:#fff">产品、设计、开发</b>相关的问题和看法，还有<b style="color:#fff">文章翻译</b>和<b style="color:#fff">分享</b>。</div><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">相信你可以在这里找到对你有用的<b style="color:#fff">知识</b>和<b style="color:#fff">教程</b>。</div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/about"><h1 class="author-info__name">这不是Cola</h1><div class="author-info__desc">今天也想见到你</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/xturboq" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%92%8CC%E8%AF%AD%E8%A8%80"><span class="toc-number">2.</span> <span class="toc-text">第1章 程序设计和C语言</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#C%E8%AF%AD%E8%A8%80%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%8A%E5%85%B6%E7%89%B9%E7%82%B9"><span class="toc-number">2.1.</span> <span class="toc-text">C语言的发展及其特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%8C%96%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95%E7%9A%84%E6%80%9D%E6%83%B3"><span class="toc-number">2.2.</span> <span class="toc-text">结构化程序设计方法的思想</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%BE%91%E3%80%81%E7%BC%96%E8%AF%91%E3%80%81%E8%BF%90%E8%A1%8C%E4%B8%80%E4%B8%AAC%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="toc-number">2.3.</span> <span class="toc-text">编辑、编译、运行一个C程序的步骤</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%81%B5%E9%AD%82"><span class="toc-number">3.</span> <span class="toc-text">第2章 算法——程序的灵魂</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">3.1.</span> <span class="toc-text">算法的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">3.2.</span> <span class="toc-text">算法的特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%8E%E6%A0%B7%E8%A1%A8%E7%A4%BA%E4%B8%80%E4%B8%AA%E7%AE%97%E6%B3%95"><span class="toc-number">3.3.</span> <span class="toc-text">怎样表示一个算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%83%BD%E5%A4%9F%E5%88%A9%E7%94%A8%E4%BC%A0%E7%BB%9F%E6%B5%81%E7%A8%8B%E5%9B%BE%E5%92%8CN-S%E6%B5%81%E7%A8%8B%E5%9B%BE%E6%8F%8F%E8%BF%B0%E7%AE%97%E6%B3%95"><span class="toc-number">3.4.</span> <span class="toc-text">能够利用传统流程图和N-S流程图描述算法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84C%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E9%A1%BA%E5%BA%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="toc-number">4.</span> <span class="toc-text">第3章 最简单的C程序设计—顺序程序设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E5%92%8C%E5%8F%98%E9%87%8F"><span class="toc-number">4.1.</span> <span class="toc-text">常量和变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8C%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-number">4.2.</span> <span class="toc-text">关键字和标识符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.3.</span> <span class="toc-text">数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">4.4.</span> <span class="toc-text">运算符与表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="toc-number">4.5.</span> <span class="toc-text">数据的输入输出</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC4%E7%AB%A0-%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="toc-number">5.</span> <span class="toc-text">第4章 选择结构程序设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E3%80%81%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">5.1.</span> <span class="toc-text">关系、逻辑运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">5.2.</span> <span class="toc-text">条件运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#if-%E8%AF%AD%E5%8F%A5"><span class="toc-number">5.3.</span> <span class="toc-text">if 语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Switch-Break-%E8%AF%AD%E5%8F%A5"><span class="toc-number">5.4.</span> <span class="toc-text">Switch Break 语句</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="toc-number">6.</span> <span class="toc-text">第5章 循环结构程序设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#while-%E5%BE%AA%E7%8E%AF"><span class="toc-number">6.1.</span> <span class="toc-text">while 循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#do-while-%E5%BE%AA%E7%8E%AF"><span class="toc-number">6.2.</span> <span class="toc-text">do while 循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#for-%E5%BE%AA%E7%8E%AF"><span class="toc-number">6.3.</span> <span class="toc-text">for 循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#break%E3%80%81continue%E4%BD%9C%E7%94%A8"><span class="toc-number">6.4.</span> <span class="toc-text">break、continue作用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-%E5%88%A9%E7%94%A8%E6%95%B0%E7%BB%84%E5%A4%84%E7%90%86%E6%89%B9%E9%87%8F%E6%95%B0%E6%8D%AE"><span class="toc-number">7.</span> <span class="toc-text">第6章 利用数组处理批量数据</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">7.1.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">7.2.</span> <span class="toc-text">一维数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">7.3.</span> <span class="toc-text">二维数组</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-%E7%94%A8%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E6%A8%A1%E5%9D%97%E5%8C%96%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="toc-number">8.</span> <span class="toc-text">第7章 用函数实现模块化程序设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">8.1.</span> <span class="toc-text">为什么要用函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0"><span class="toc-number">8.2.</span> <span class="toc-text">定义函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">8.3.</span> <span class="toc-text">调用函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%80%92%E5%BD%92"><span class="toc-number">8.4.</span> <span class="toc-text">函数递归</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="toc-number">8.5.</span> <span class="toc-text">数组作为函数参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%92%8C%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-number">8.6.</span> <span class="toc-text">局部变量和全局变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%E5%92%8C%E7%94%9F%E5%AD%98%E6%9C%9F"><span class="toc-number">8.7.</span> <span class="toc-text">变量的存储方式和生存期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%AD%98%E5%82%A8%E7%B1%BB%E5%88%AB"><span class="toc-number">8.8.</span> <span class="toc-text">局部变量的存储类别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%AD%98%E5%82%A8%E7%B1%BB%E5%88%AB"><span class="toc-number">8.9.</span> <span class="toc-text">全局变量存储类别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E5%87%BD%E6%95%B0%E4%B8%8E%E5%86%85%E9%83%A8%E5%87%BD%E6%95%B0"><span class="toc-number">8.10.</span> <span class="toc-text">外部函数与内部函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-%E5%96%84%E4%BA%8E%E5%88%A9%E7%94%A8%E6%8C%87%E9%92%88"><span class="toc-number">9.</span> <span class="toc-text">第8章 善于利用指针</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E7%9A%84%E5%90%AB%E4%B9%89"><span class="toc-number">9.1.</span> <span class="toc-text">指针的含义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F"><span class="toc-number">9.2.</span> <span class="toc-text">指针变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%BC%95%E7%94%A8%E6%95%B0%E7%BB%84"><span class="toc-number">9.3.</span> <span class="toc-text">指针引用数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%BC%95%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">9.4.</span> <span class="toc-text">指针引用字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E5%90%91%E5%87%BD%E6%95%B0%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">9.5.</span> <span class="toc-text">指向函数的指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">9.6.</span> <span class="toc-text">动态内存分配</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-%E7%94%A8%E6%88%B7%E8%87%AA%E5%B7%B1%E5%BB%BA%E7%AB%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">10.</span> <span class="toc-text">第9章 用户自己建立数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%98%E9%87%8F"><span class="toc-number">10.1.</span> <span class="toc-text">结构体变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E6%8C%87%E9%92%88"><span class="toc-number">10.2.</span> <span class="toc-text">结构体指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%A4%84%E7%90%86%E9%93%BE%E8%A1%A8"><span class="toc-number">10.3.</span> <span class="toc-text">指针处理链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B1%E7%94%A8%E4%BD%93%E7%B1%BB%E5%9E%8B"><span class="toc-number">10.4.</span> <span class="toc-text">共用体类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="toc-number">10.5.</span> <span class="toc-text">枚举类型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-%E5%AF%B9%E6%96%87%E4%BB%B6%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="toc-number">11.</span> <span class="toc-text">第10章 对文件的输入输出</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#C%E6%96%87%E4%BB%B6%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86"><span class="toc-number">11.1.</span> <span class="toc-text">C文件基本知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%93%E5%BC%80%E4%B8%8E%E5%85%B3%E9%97%AD%E6%96%87%E4%BB%B6"><span class="toc-number">11.2.</span> <span class="toc-text">打开与关闭文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%AD%97%E7%AC%A6%E8%AF%BB%E5%86%99"><span class="toc-number">11.3.</span> <span class="toc-text">文件字符读写</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%AF%BB%E5%86%99"><span class="toc-number">11.4.</span> <span class="toc-text">文件字符串读写</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%96%B9%E5%BC%8F%E8%AF%BB%E5%86%99%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6"><span class="toc-number">11.5.</span> <span class="toc-text">格式化方式读写文本文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE%E5%9D%97%E8%AF%BB%E5%86%99"><span class="toc-number">11.6.</span> <span class="toc-text">二进制文件数据块读写</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6"><span class="toc-number">11.7.</span> <span class="toc-text">随机读写数据文件</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/06/07/LearnLink/" title="LearnLink伙伴匹配系统笔记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xykcola.site/blogPics/post/202405/202405271431216.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="LearnLink伙伴匹配系统笔记"/></a><div class="content"><a class="title" href="/2024/06/07/LearnLink/" title="LearnLink伙伴匹配系统笔记">LearnLink伙伴匹配系统笔记</a><time datetime="2024-06-07T14:56:23.000Z" title="发表于 2024-06-07 22:56:23">2024-06-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/04/02/Node_install/" title="Node.js的下载及安装"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xykcola.site/blogPics/post/202405/202405271602052.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Node.js的下载及安装"/></a><div class="content"><a class="title" href="/2024/04/02/Node_install/" title="Node.js的下载及安装">Node.js的下载及安装</a><time datetime="2024-04-02T02:00:00.000Z" title="发表于 2024-04-02 10:00:00">2024-04-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/03/31/C%20%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/" title="C 语言笔记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xykcola.site/blogPics/post/202405/202405271431216.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C 语言笔记"/></a><div class="content"><a class="title" href="/2024/03/31/C%20%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/" title="C 语言笔记">C 语言笔记</a><time datetime="2024-03-31T09:25:00.000Z" title="发表于 2024-03-31 17:25:00">2024-03-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/03/30/test/" title="生活不易，小狗叹气"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xykcola.site/blogPics/post/202405/202405271547540.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="生活不易，小狗叹气"/></a><div class="content"><a class="title" href="/2024/03/30/test/" title="生活不易，小狗叹气">生活不易，小狗叹气</a><time datetime="2024-03-30T02:00:00.000Z" title="发表于 2024-03-30 10:00:00">2024-03-30</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="footer_deal"><a class="deal_link" href="mailto:hifz@vip.qq.com" title="email"><i class="anzhiyufont anzhiyu-icon-envelope"></i></a><a class="deal_link" href="/atom.xml" title="RSS"><i class="anzhiyufont anzhiyu-icon-rss"></i></a><img class="footer_mini_logo" title="返回顶部" alt="返回顶部" onclick="anzhiyu.scrollToDest(0, 500)" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="http://cdn.xykcola.site/blogPics/element/1712495829972.jpg" size="50px"/><a class="deal_link" target="_blank" rel="noopener" href="https://github.com/xturboq" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="deal_link" href="/copyright" title="CC"><i class="anzhiyufont anzhiyu-icon-copyright-line"></i></a></div><div id="anzhiyu-footer"><div class="footer-group"><div class="footer-title">服务</div><div class="footer-links"><a class="footer-item" title="51la统计" target="_blank" rel="noopener" href="https://v6.51.la/">51la统计</a><a class="footer-item" title="十年之约" target="_blank" rel="noopener" href="https://www.foreverblog.cn/">十年之约</a><a class="footer-item" title="开往" target="_blank" rel="noopener" href="https://github.com/travellings-link/travellings">开往</a></div></div><div class="footer-group"><div class="footer-title">主题</div><div class="footer-links"><a class="footer-item" title="文档" href="/docs/">文档</a><a class="footer-item" title="源码" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu">源码</a></div></div><div class="footer-group"><div class="footer-title">导航</div><div class="footer-links"><a class="footer-item" title="即刻短文" href="/essay/">即刻短文</a><a class="footer-item" title="友链文章" href="/fcircle/">友链文章</a><a class="footer-item" title="留言板" href="/comments/">留言板</a></div></div><div class="footer-group"><div class="footer-title">协议</div><div class="footer-links"><a class="footer-item" title="隐私协议" href="/privacy/">隐私协议</a><a class="footer-item" title="Cookies" href="/cookies/">Cookies</a><a class="footer-item" title="版权协议" href="/copyright/">版权协议</a></div></div><div class="footer-group"><div class="footer-title-group"><div class="footer-title">友链</div><a class="random-friends-btn" id="footer-random-friends-btn" href="javascript:addFriendLinksInFooter();" title="换一批友情链接"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right"></i></a></div><div class="footer-links" id="friend-links-in-footer"></div></div></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v5.4.0" title="博客框架为Hexo_v5.4.0"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Frame-Hexo.svg" alt="博客框架为Hexo_v5.4.0"/></a><a class="github-badge" target="_blank" href="https://blog.anheyu.com/" style="margin-inline:5px" data-title="本站使用AnZhiYu主题" title="本站使用AnZhiYu主题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.9/img/Theme-AnZhiYu-2E67D3.svg" alt="本站使用AnZhiYu主题"/></a><a class="github-badge" target="_blank" href="https://beian.miit.gov.cn/#/Integrated/index" style="margin-inline:5px" data-title="本站已在吉进行备案" title="本站已在吉进行备案"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xykcola.site/blogPics/element/badge/%E5%90%89ICP%E5%A4%87-2024014764%E5%8F%B7.png" alt="本站已在吉进行备案"/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title="本站项目由Github托管"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Source-Github.svg" alt="本站项目由Github托管"/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.2.0/img/badge/Copyright-BY-NC-SA.svg" alt="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"/></a></p></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2024 By <a class="footer-bar-link" href="/" title="这不是Cola" target="_blank">这不是Cola</a></div></div><div id="footer-type-tips"></div><div class="js-pjax"><script>function subtitleType () {
  fetch('https://v1.hitokoto.cn')
    .then(response => response.json())
    .then(data => {
      if (true) {
        const from = '出自 ' + data.from
        const sub = ["今天也想见到你&#44; 不管什么天气。"]
        sub.unshift(data.hitokoto, from)
        window.typed = new Typed('#footer-type-tips', {
          strings: sub,
          startDelay: 300,
          typeSpeed: 150,
          loop: true,
          backSpeed: 50,
        })
      } else {
        document.getElementById('footer-type-tips').innerHTML = data.hitokoto
      }
    })
}

if (true) {
  if (typeof Typed === 'function') {
    subtitleType()
  } else {
    getScript('https://cdn.cbd.int/typed.js@2.1.0/dist/typed.umd.js').then(subtitleType)
  }
} else {
  subtitleType()
}
</script></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a><a class="footer-bar-link" target="_blank" rel="noopener" href="https://beian.miit.gov.cn/" title="吉ICP备-2024014764号">吉ICP备-2024014764号</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">4</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">3</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" href="https://blog.xykcola.site/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xykcola.site/blogPics/element/1712495829972.jpg" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="http://user.xykcola.site/" title="用户中心"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xykcola.site/userPics/ele/logo.png" alt="用户中心"/><span class="back-menu-item-text">用户中心</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=320403036&amp;server=netease"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/C%E8%AF%AD%E8%A8%80/" style="font-size: 0.88rem;">C语言<sup>1</sup></a><a href="/tags/Java/" style="font-size: 0.88rem;">Java<sup>1</sup></a><a href="/tags/%E7%94%9F%E6%B4%BB/" style="font-size: 0.88rem;">生活<sup>1</sup></a><a href="/tags/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/" style="font-size: 0.88rem;">项目开发<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("06/01/2023 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 V1.6.12",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 这不是Cola 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><script>(() => {
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo.xykcola.site/',
      region: '',
      onCommentLoaded: () => {
        anzhiyu.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(runFn,0)
    else getScript('https://cdn.cbd.int/twikoo@1.6.25/dist/twikoo.all.min.js').then(runFn)
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.xykcola.site/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const runFn = () => {
    init();
    
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) anzhiyu.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else {
      loadTwikoo()
    }
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getComment = () => {
    const runTwikoo = () => {
      twikoo.getRecentComments({
        envId: 'https://twikoo.xykcola.site/',
        region: '',
        pageSize: 6,
        includeReply: true
      }).then(function (res) {
        const twikooArray = res.map(e => {
          return {
            'content': changeContent(e.comment),
            'avatar': e.avatar,
            'nick': e.nick,
            'url': e.url + '#' + e.id,
            'date': new Date(e.created).toISOString()
          }
        })

        saveToLocal.set('twikoo-newest-comments', JSON.stringify(twikooArray), 10/(60*24))
        generateHtml(twikooArray)
      }).catch(function (err) {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      })
    }

    if (typeof twikoo === 'object') {
      runTwikoo()
    } else {
      getScript('https://cdn.cbd.int/twikoo@1.6.25/dist/twikoo.all.min.js').then(runTwikoo)
    }
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'><div class='name'><span>${array[i].nick} </span></div></a>`
        }
        
        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <time datetime="${array[i].date}">${anzhiyu.diffDate(array[i].date, true)}</time></div>
        </div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom && ($dom.innerHTML= result)
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('twikoo-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","meta[property=\"og:type\"]","meta[property=\"og:site_name\"]","meta[property=\"og:description\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: true,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', 'G-NV871JX04X', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>